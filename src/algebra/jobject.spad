)abbrev category JOBTYPE JLObjectType
++ Category for arbitrary Julia objects
++ Author: G.Vanuxem
++ Date Created: April. 2024
++ Description:
++  Category for arbitrary Julia objects, more precisely
++  objects that are used within Julia.
JLObjectType() : Category == JLType() with
    jlref   : String -> %
    ++ jlref(str) evaluates the Julia command str and returns
    ++ the corresponding FriCAS Julia object.
    jlId    : % -> JLInt64
    ++ jlId(obj) returns the Julia indexed dictionary index related
    ++ to the object obj.
    jlType  : % -> String
    ++ jlType(obj) return the Julia type of obj.
    jlRef   : % -> SExpression
    ++ jlRef(obj) returns the pretty printed internal Lisp representation
    ++ of the Julia object obj.
    jlDump : JLObject -> Void
    ++ jlDump(obj) dumps (shows) the Julia object (internal structure with type).
    mutable? : % -> Boolean
    ++ mutable?(obj) checks whether or not obj is mutable.
    nothing? : % -> Boolean
    ++ nothing?(obj) checks whether or not obj is nothing.
    jlDisplay: % -> Void
    ++ jlDisplay(v) pretty prints v (Ã  la Julia).
    jlApply : (String, %) -> %
    ++jlApply(func, obj) applies the function func with obj as parameter
    ++ and returns the result as a FriCAS JLObject.
    ++ For example, using JLMatrix(JLObjFloat64):
    ++ \example{M:=nrand(4,4);}
    ++ \example{jlApply("svd", M::JLMatrix(JLObjFloat64)).S}
    ++ should be "equivalent" to svdvals(M)
    jlApply : (String, %, %) -> %
    ++jlApply(func, obj1, obj2) applies the function func with obj1 and obj2
    ++ as parameters and returns the result as a FriCAS JLObject.
    ++ For example (equivalent to map(cos, v)):
    ++ \example{v:=urand01(5)$JLVector(JLFloat)}
    ++ \example{jlApply("map", "cos", coerce v)}
    jlApply : (String, %, %, %) -> %
    ++ jlApply(func, obj1, obj2, obj3) applies the function func with obj1, obj2
    ++ and obj3 as parameters and returns the result as a FriCAS JLObject.
    jlApply : (String, %, %, %, %) -> %
    ++ jlApply(func, obj1, obj2, obj3, obj4) applies the function func with obj1, obj2,
    ++ obj3 and obj4 as parameters and returns the result as a FriCAS JLObject.
    jlApply : (String, %, %, %, %, %) -> %
    ++ jlApply(func, obj1, obj2, obj3, obj4, obj5) applies the function func with obj1,
    ++ obj2, obj3, obj4 and obj5 as parameters and returns the result as a FriCAS
    ++ JLObject.
    jlAbout : % -> Void
    ++ jlAbout(obj) displays Julia informations about obj
    ++ if you have About.jl installed in Julia.
    ++ In the Julia interpreter enter in the package management mode
    ++ with ']' and issue:
    ++ pkg> add "https://github.com/tecosaur/About.jl"
    jlObject : () -> String
    ++ jlObject() returns the internal Julia name of the Julia module used.
    coerce  : % -> JLObject
    ++ coerce(obj) coerce obj to JLObject.
    ++ Convenience function.
  add
    import from JLUtilityFunctions
    import from JLSymbol
    import from String

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)),")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func,a,b) ==> make_jlref_wcall2(func, a, b)$Lisp
    jterfunc(func,a,b,c) ==> make_jlref_wcall3(func, a, b, c)$Lisp
    jquatfunc(func,a,b,c,d) ==> make_jlref_wcall4(func, a, b, c, d)$Lisp
    jquinfunc(func,a,b,c,d,e) ==>
      make_jlref_wcall5(func, a, b, c, d, e)$Lisp
    defined?(func) ==>
      not jlDefined?(func)$JLUtilityFunctions =>
        error concat(func, " is not defined in Julia")

    jlref(cmd)   == make_jlref(cmd)$Lisp  
    jlId(obj)    == JLREFID(obj)$Lisp
    jlType(obj)  == jlEvalString(concat(["string(typeof(",getind(obj),"))"]))
    jlRef(obj)   == obj pretend SExpression
    jlDump(obj)  == jlEvalString(concat(["dump(", getind(obj),")"]))

    x = y == jl_call2_bool_wrapped_index("==", jlId(x), jlId(y))$Lisp
    x ~= y == jl_call2_bool_wrapped_index("!=", jlId(x), jlId(y))$Lisp
    mutable?(x) == jl_call1_bool_wrapped_index("ismutable", jlId(x))$Lisp
    nothing?(x) == jl_call1_bool_wrapped_index("isnothing", jlId(x))$Lisp

    jlDisplay(v) ==
      jlEvalString(concat(["display(", getind(v), ")"]))
    jlApply(func, a) ==
      defined?(func)
      junfunc(func, a)
    jlApply(func, a, b) ==
      defined? func
      jbinfunc(func,a,b)
    jlApply(func, a, b, c) ==
      defined? func
      jterfunc(func,a,b,c)
    jlApply(func, a, b, c, d) ==
      defined? func
      jquatfunc(func,a,b,c,d)
    jlApply(func, a, b, c, d, e) ==
      defined? func
      jquinfunc(func,a,b,c,d,e)
    jlAbout(obj) ==
      not jlUsing("About") =>
        error(concat("jlAbout: the _"About.jl_" Julia package is not installed.",
          " See the JLObjectType category for information"))
      jlEvalString(concat(["about(", getind(obj),")"]))@Void
    coerce(obj : %) : OutputForm ==
      ret : List OutputForm := jl_stringify_wrapped_index("show",
        "_"text/plain_"", jlId(obj))$Lisp
      -- first line length only
      #ret ~= 1 or more?(elt(ret,1) pretend String, _$LINELENGTH$Lisp)
        => pile(append(["" pretend OutputForm], ret))
      vconcat(ret)
    string(obj)  == jl_string_getindex(jlId obj)$Lisp
    convert(obj)  == jl_string_getindex(jlId obj)$Lisp
    coerce(obj : %) == obj pretend JLObject

)abbrev category JOBAGG JLObjectAggregate
++ Category for arbitrary Julia aggregates
++ Author: G.Vanuxem
++ Date Created: Aug. 2024
++ Description:
++  Category for arbitrary Julia aggregates.
JLObjectAggregate() : Category == Join(JLObjectType, Aggregate) with
    elt : (%, JLSymbol) -> JLObject
    ++ elt(obj, sym) returns the property sym of obj.
    ++ For example:
    ++ \example{ret := jlApply("svd", jobject("rand(4,4)")); ret.U}
    qelt : (%, JLSymbol) -> JLObject
    ++ qelt(obj, sym) returns the property sym of obj. No checks are done
    ++ regarding the existence of the sym property. If it does not exist,
    ++ Julia throws an error.
    elt : (%, Integer) -> JLObject
    ++ elt(obj, ind) returns the element at index ind of obj.
    ++ It can be used, for example, with a Tuple or a Vector.
    qelt : (%, Integer) -> JLObject
    ++ qelt(obj, ind) returns the element at index ind of obj.
    ++ It can be used, for example, with a Tuple or a Vector.
  add
    import from JLUtilityFunctions
    import from String

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    elt(obj : %, jsy : JLSymbol) ==
      defined := concat(["hasproperty(", getind(obj), ",",
        str := string(jsy), ")"])
      not jlEvalString(defined)@Boolean =>
        error concat("elt: undefined symbol ", str)
      jlref(concat(["getproperty(", getind(obj), ",", string(jsy), ")"]))
    qelt(obj : %, jsy : JLSymbol) ==
      jlref(concat(["get(", getind(obj), ",", string(jsy), ", missing)"]))
    elt(obj : %, ind : Integer) ==
      -- TDOD: do some checks and use a method compatible with Dict
      jlref(concat([getind(obj), "[", string(ind), "]"]))
    qelt(obj : %, ind : Integer) ==
      jlref(concat([getind(obj), "[", string(ind), "]"]))
    empty() == jlref("missing")
    empty? m ==
      jlEvalString(concat(["ismissing(", getind(m),")"]))@Boolean

)abbrev category JOBRING JLObjectRing
++ Category for Julia object rings
++ Author: G.Vanuxem
++ Date Created: Aug, 2024
++ Description:
++  Category of rings whose elements are of type JLOjectType.
JLObjectRing() : Category == Join(JLObjectType, JLRing) with
    "*" : (NMInteger, %) -> %
    ++ i*x is the integer multiplication.
  add
    import JLUtilityFunctions
    import from String
    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    junbfunc(bfunc, a) ==> jl_call1_bool_wrapped_index(bfunc, jlId(a))$Lisp
    jbinfunc(func,a,b) ==> make_jlref_wcall2(func, a, b)$Lisp

    zero?(x) == junbfunc("iszero", x)
    one?(x) == junbfunc("isone", x)
    x + y == jbinfunc("+", x, y)
    x - y == jbinfunc("-", x, y)
    - x   == junfunc("-", x)
    x : % * y : % == jbinfunc("*", x, y)
    x : NMInteger * y : % == jbinfunc("*", x, y)
    x : Integer * y : % == jlref(concat([string(x), "*", getind(y)]))
    x : PositiveInteger * y : % == jlref(concat([string(x), "*", getind(y)]))
    x : NonNegativeInteger * y : % == jlref(concat([string(x), "*", getind(y)]))
    x ^ y : PositiveInteger == jlref(concat [getind(x), "^", string(y)])
    x ^ y : NonNegativeInteger == jlref(concat [getind(x), "^", string(y)])

)abbrev domain JOBJECT JLObject
++ Generic domain for Julia objects
++ Author: G.Vanuxem
++ Date Created: April. 2024
++ Description:
++  Generic Julia objects i.e. objects that are used within Julia,
++ and not directly by the underlying FriCAS Common LISP. It also
++ supports the JLObjectAggregate category.
JLObject() : Exports == Implementation where
  INT ==> Integer
  NNI ==> NonNegativeInteger
  Exports ==> JLObjectAggregate with
    coerce  : JLSymbol -> %
    ++ coerce(x): convenience function.
    -- TODO: use a specific JLObjType domain
    coerce  : String -> %
    ++ coerce(str) coerces str as a JLObject.
    ++ See 'jobject(String)' for more information. Convenience function.
    coerce  : Integer -> %
    ++ coerce(i) coerces i as a JLObject.
    ++ Convenience function.
    jlCollect : % -> JLVector(%)
    ++ jlCollect(obj) collects element of a Julia iterator
    ++ in a JLVector.
    jobject : Integer -> %
    ++ jobject(n) returns the JLObject representing the integer n.
    jobject : String -> %
    ++ jobject(str) constructs an arbitrary Julia object depending
    ++ on string used (evaluated by Julia). For example:
    ++ \example{jobject("rand(Float64,(2,3,4))")}
    ++ returns a 2x3x4 array of Float64 elements.
    ++ A Julia exception is raised if error(s) occur(s)
    ++ during parsing/evalution.
  Implementation ==> add
    import from JLUtilityFunctions
    import from String

    jlInitialize(true)
    Rep := SExpression
    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    jlCollect(obj) == jlref(concat ["collect(", getind(obj),")"])
    coerce(jsy : JLSymbol ) == jlref(convert(jsy))
    coerce(i: Integer) == jlref(string i)
    coerce(str : String) : % == jlref(str)
    jobject(i: Integer) : % == jlref(string i)
    jobject(str: String) : % == jlref(str)

)abbrev domain JOBBOOL JLObjBoolean
++ Convenience domain for Julia booleans
++ Author: G.Vanuxem
++ Date Created: Aug. 2024
++ Description:
++  Convenience domain for Julia booleans, objects that are used
++ within Julia, and not directly by the underlying FriCAS Common LISP.
++ It is not meant to be used directly, but rather for returned value
++ or function argument for example.
JLObjBoolean() : Exports == Implementation where
  Exports ==> JLObjectType with
    coerce : % -> Boolean
    ++ coerce(jbool) coerces the Julia boolean value to a
    ++ FriCAS Boolean.
    jtrue : () -> %
    ++ jtrue() returns the Julia boolean true value.
    jfalse : () -> %
    ++ jfalse() returns the Julia boolean false value.
  Implementation ==> add
    import String
    coerce(bool) : Boolean == jl_string_getindex(jlId bool)$Lisp = "true"
    jtrue() == jlref("true")
    jfalse() == jlref("false")
 
)abbrev domain JOBF32 JLObjFloat32
++ Convenience domain for Julia Float32
++ Author: G.Vanuxem
++ Date Created: Aug. 2024
++ Description:
++  Convenience domain for Julia Float32, objects that are used
++ within Julia, and not directly by the underlying FriCAS Common LISP.
++ It is not meant to be used directly, but rather, for returned value
++ or function argument for example.
++ Only basic arithmetic operations are supported.
JLObjFloat32() : Exports == Implementation where
  Exports ==> Join(OrderedSet, JLObjectRing, Field) with
    "*" : (%, Integer) -> %
    ++ x*i is the multiplication of x by an integer.
    "/" : (%, Integer) -> %
    ++ x/i is the division of x by an integer.
    "/" : (Integer, %) -> %
    ++ i/x is the division of an integer by x.
    "^" : (%, Fraction(Integer)) -> %
    ++ x^q is the exponentiation by a rational.
    jlApprox?: (%, %) -> Boolean
    ++ jlApprox?(x,y) computes inexact equality comparison
    ++ with default parameters.
    ++ Two numbers compare equal if their relative distance
    ++ or their absolute distance is within tolerance bounds.
    jlApprox?: (%, %, %) -> Boolean
    ++ jlApprox?(x,y,atol) computes inexact equality comparison
    ++ with absolute tolerance atol.
    ++ Two numbers compare equal if their relative distance
    ++ or their absolute distance is within tolerance bounds.
    jlF32CApply : (JLObjDynamicLinker, %) -> %
    ++ jlF32CApply(func,x) applies the function pointer func to x.
    ++ For example:
    ++ \example{libm:= jlDlOpen "libopenlibm"}
    ++ \example{squareRoot:=jlDlSym(libm,jsym(sqrtf))}
    ++ \example{jlF32CApply(squareRoot,jfloat32(2))}
    jlF32CApply : (JLObjDynamicLinker, %, %) -> %
    ++ jlF32CApply(func,x,y) applies the function pointer func to x and y.
    ++ For example:
    ++ \example{libm:= jlDlOpen "libopenlibm"}
    ++ \example{power:=jlDlSym(libm,jsym(powf))}
    ++ \example{jlF32CApply(power,jfloat32(2),jfloat32(7))}
    jlF32CApply : (JLObjDynamicLinker, %, %, %) -> %
    ++ jlF32CApply(func,x,y,z) applies the function pointer func to x, y and z.
    cis : % -> JLObjComplexF32
    ++ cis(x) returns exp(%i*x) computed efficiently.
    cispi : % -> JLObjComplexF32
    ++ cispi(x) returns cis(%pi*x) computed efficiently.
    convert : Float -> %
    ++ convert(x) returns x as a JLObjFloat32 (truncate it).
    coerce : DoubleFloat -> %
    ++ coerce(x) returns x as a JLObjFloat32 (truncate it).
    ++ Convenience function.
    coerce : Float -> %
    ++ coerce(x) returns x as a JLObjFloat32 (truncate it).
    ++ Convenience function.
    jfloat32 : Float -> %
    ++ jfloat32(x) returns x as a JLObjFloat32 (truncate it).
    jfloat32 : JLFloat32 -> %
    ++ jfloat32(x) returns x as a JLObjFloat32 (truncate it).
    jfloat32 : String -> %
    ++ jfloat32(str) evaluates str in Julia and returns the
    ++ Julia Float32 object. For example:
    ++\example{jfloat32("sin(pi)")}
    ++\example{jfloat32("0.7")}
  Implementation ==> add
    import from JLUtilityFunctions
    import from String

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func,a,b) ==> make_jlref_wcall2(func, a, b)$Lisp
    jbinbfunc(op,a,b) ==>
      jl_call2_bool_wrapped_index(op, jlId(a), jlId(b))$Lisp

    jlInitialize(true)
    Rep := SExpression

    0 == jlref("0.0")
    1 == jlref("1.0")
    x < y  == jbinbfunc("<",x,y)
    x > y  == jbinbfunc(">",x,y)
    x >= y == jbinbfunc(">=",x,y)
    x <= y == jbinbfunc("<=",x,y)
    characteristic() == 0
    x : % * a : Integer == jlref(concat [getind(x),"*",string(a)])
    x : Fraction(Integer) * y : % ==
      jlref(concat ["(",string(numer x), "//" , string(denom(x)) ")*", getind(y)])
    x : % * y : Fraction(Integer) ==
      jlref(concat [getind(x), "*(", string(numer(y)),"//", string(denom(y)), ")"])
    x : % ^ y : Fraction(Integer) ==
      jlref(concat [getind(x), "^(", string(numer(y)),"//", string(denom(y)), ")"])
    x : % / y : % == jbinfunc("/",x,y)
    x : % / i : Integer == jlref(concat [getind(x) , "/", string(i)])
    i : Integer / x : % == jlref(concat [string(i), "/", getind(x)])

    jlApprox?(x, y) == jbinbfunc("isapprox",x,y)
    jlApprox?(x, y, atol) ==
      jlEvalString(concat(["isapprox(", getind(x),
        ",", getind(y), ", atol=", getind(atol),")"]))@Boolean

    jlF32CApply(func, x) ==
      jlref(concat ["ccall(", getind(func),
        ", Float32, (Float32,),", getind(x),")"])
    jlF32CApply(func, x, y) ==
      jlref(concat ["ccall(", getind(func),
        ", Float32, (Float32,Float32),", getind(x), ",", getind(y),")"])
    jlF32CApply(func, x, y, z) ==
      jlref(concat ["ccall(", getind(func), 
        ", Float32, (Float32,Float32,Float32),",
          getind(x), ",", getind(y), ",", getind(z), ")"])
    cis(x)   == junfunc("cis",x)
    cispi(x) == junfunc("cispi",x)
    convert(r: Float) ==
      tmp := outputSpacing(0)
      ret := jlref(toString(r))
      outputSpacing(tmp)
      ret
    coerce(r : DoubleFloat) == jlref(toString(r))
    coerce(r : Float) == convert(r)
    jfloat32(r : Float) == convert(r)
    jfloat32(r : JLFloat32) == jlref(toString(r))
    jfloat32(str : String) ==
      ret : % := jlref(str)
      jlType(ret) ~= "Float32" => error "jfloat32: not a Julia Float32"
      ret

)abbrev domain JOBF64 JLObjFloat64
++ Convenience domain for Julia Float64
++ Author: G.Vanuxem
++ Date Created: Aug. 2024
++ Description:
++  Convenience domain for Julia Float64, objects that are used
++ within Julia, and not directly by the underlying FriCAS Common LISP.
++ It is not meant to be used directly, but rather, for returned value
++ or function argument for example.
++ Only basic arithmetic operations are supported.
JLObjFloat64() : Exports == Implementation where
  Exports ==> Join(OrderedSet, JLObjectRing, Field) with
    "*" : (%, Integer) -> %
    ++ x*i is the integer multiplication.
    "/" : (%, Integer) -> %
    ++ x/i is the division by an integer.
    "/" : (Integer, %) -> %
    ++ i/x is the division of an integer by x.
    "^" : (%, Fraction(Integer)) -> %
    ++ x^q is the exponentiation by a rational.
    jlApprox?: (%, %) -> Boolean
    ++ jlApprox?(x,y) computes inexact equality comparison
    ++ with default parameters.
    ++ Two numbers compare equal if their relative distance
    ++ or their absolute distance is within tolerance bounds.
    jlApprox?: (%, %, %) -> Boolean
    ++ jlApprox?(x,y,atol) computes inexact equality comparison
    ++ with absolute tolerance atol.
    ++ Two numbers compare equal if their relative distance
    ++ or their absolute distance is within tolerance bounds.
    jlF64CApply : (JLObjDynamicLinker, %) -> %
    ++ jlF64CApply(func,x) applies the function pointer func to x.
    ++ For example:
    ++ \example{libm:= jlDlOpen "libopenlibm"}
    ++ \example{squareRoot:=jlDlSym(libm,jsym(sqrt))}
    ++ \example{jlF64CApply(squareRoot,jfloat64(2))}
    jlF64CApply : (JLObjDynamicLinker, %, %) -> %
    ++ jlF64CApply(func,x,y) applies the function pointer func to x and y.
    ++ For example:
    ++ \example{libm:= jlDlOpen "libopenlibm"}
    ++ \example{power:=jlDlSym(libm,jsym(pow))}
    ++ \example{jlF64CApply(power,jfloat64(2),jfloat64(7))}
    jlF64CApply : (JLObjDynamicLinker, %, %, %) -> %
    ++ jlF64CApply(func,x,y,z) applies the function pointer func to x, y and z.
    ++ For example with GSL-2.8:
    ++ \example{gsl:= jlDlOpen "libgsl.so.28"}
    ++ \example{hypot3:= jlDlSym(gsl,jsym(gsl_hypot3))}
    ++ \example{jlF64CApply(hypot3,jfloat64(2),jfloat64(7),jfloat64(9.0))}
    cis : % -> JLObjComplexF64
    ++ cis(x) returns exp(%i*x) computed efficiently.
    cispi : % -> JLObjComplexF64
    ++ cispi(x) returns cis(%pi*x) computed efficiently.
    convert : Float -> %
    ++ convert(x) returns x as a JLObjFloat64 (truncate it).
    coerce : DoubleFloat -> %
    ++ coerce(x) returns x as a JLObjFloat64.
    coerce : Float -> %
    ++ coerce(x) returns x as a JLObjFloat64 (truncate it)
    ++ Convenience function.
    jfloat64 : Float -> %
    ++ jfloat64(x) returns x as a JLObjFloat64 (truncate it).
    jfloat64 : JLFloat64 -> %
    ++ jfloat64(x) returns x as a JLObjFloat64 i.e. returns
    ++ a 64 bits float in the memory area of Julia from
    ++ the memory area of the underlying Common Lisp implementation.
    jfloat64 : String -> %
    ++ jfloat64(str) evaluates str in Julia and returns the
    ++ Julia Float64 object. For example:
    ++\example{jfloat64("sin(pi)")}
    ++\example{jfloat64("0.7")}
  Implementation ==> add
    import from JLUtilityFunctions
    import from String

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func,a,b) ==> make_jlref_wcall2(func, a, b)$Lisp
    jbinbfunc(op,a,b) ==>
      jl_call2_bool_wrapped_index(op, jlId(a), jlId(b))$Lisp

    jlInitialize(true)
    Rep := SExpression

    0 == jlref("0.0")
    1 == jlref("1.0")
    x < y  == jbinbfunc("<",x,y)
    x > y  == jbinbfunc(">",x,y)
    x >= y == jbinbfunc(">=",x,y)
    x <= y == jbinbfunc("<=",x,y)
    characteristic() == 0
    x : % * a : Integer == jlref(concat [getind(x),"*",string(a)])
    x : Fraction(Integer) * y : % ==
      jlref(concat ["(",string(numer x), "//" , string(denom(x)) ")*", getind(y)])
    x : % * y : Fraction(Integer) ==
      jlref(concat [getind(x), "*(", string(numer(y)),"//", string(denom(y)), ")"])
    x : % ^ y : Fraction(Integer) ==
      jlref(concat [getind(x), "^(", string(numer(y)),"//", string(denom(y)), ")"])
    x : % / y : % == jbinfunc("/",x,y)
    x : % / i : Integer == jlref(concat [getind(x) , "/", string(i)])
    i : Integer / x : % == jlref(concat [string(i), "/", getind(x)])

    jlApprox?(x, y) == jbinbfunc("isapprox",x,y)
    jlApprox?(x, y, atol) ==
      jlEvalString(concat(["isapprox(", getind(x),
        ",", getind(y), ", atol=", getind(atol),")"]))@Boolean

    jlF64CApply(func, x) ==
      jlref(concat ["ccall(", getind(func),
        ", Float64, (Float64,),", getind(x),")"])
    jlF64CApply(func, x, y) ==
      jlref(concat ["ccall(", getind(func),
        ", Float64, (Float64,Float64),", getind(x), ",", getind(y),")"])
    jlF64CApply(func, x, y, z) ==
      jlref(concat ["ccall(", getind(func), 
        ", Float64, (Float64,Float64,Float64),",
          getind(x), ",", getind(y), ",", getind(z), ")"])
    cis(x)   == junfunc("cis",x)
    cispi(x) == junfunc("cispi",x)
    convert(r: Float) ==
      tmp := outputSpacing(0)
      ret := jlref(toString(r))
      outputSpacing(tmp)
      ret
    coerce(r : DoubleFloat) == jlref(toString(r))
    coerce(r : Float) == convert(r)
    jfloat64(r : Float) == convert(r)
    jfloat64(r : JLFloat64) == jlref(toString(r))
    jfloat64(str : String) ==
      ret : % := jlref(str)
      jlType(ret) ~= "Float64" => error "jfloat64: not a Julia Float64"
      ret

)abbrev domain JOBCF32 JLObjComplexF32
++ Convenience domain for Julia ComplexF32
++ Author: G.Vanuxem
++ Date Created: Aug. 2024
++ Description:
++  Convenience domain for Julia ComplexF32, objects that are used
++ within Julia, and not directly by the underlying FriCAS Common LISP.
++ It is not meant to be used directly, but rather for returned value
++ or function argument for example.
++ Only basic arithmetic operations are supported.
JLObjComplexF32() : Exports == Implementation where
  Exports ==> Join(JLObjectRing, Field) with
    "*" : (%, Integer) -> %
    ++ x*i is the integer multiplication.
    "/" : (%, Integer) -> %
    ++ x/i is the division by an integer.
    "/" : (Integer, %) -> %
    ++ i/x is the division of an integer by x.
    jlApply : (String, %) -> %
    ++jlApply(func, x) applies the function func with x as parameter.
    jlApply : (String, %, %) -> %
    ++jlApply(func, x, y) applies the function func to x and y.
    jlApply : (String, %, %, %) -> %
    ++ jlApply(func, x, y, z) applies the function func to x,
    ++ y and z.
    cis : % -> %
    ++ cis(x) returns exp(%i*x) computed efficiently.
    cispi : % -> %
    ++ cispi(x) returns cis(%pi*x) computed efficiently.
    jcfloat32 : String -> %
    ++ jcfloat32(str) evaluates str in Julia and returns the Julia
    ++ Complex{Float32} object.
    ++ For example:
    ++ \example{jcfloat32 "cos(2pi)im"}
  Implementation ==> add
    import from JLUtilityFunctions
    import from String

    jlInitialize(true)
    Rep := SExpression

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func, a, b) ==> make_jlref_wcall2(func, a, b)$Lisp
    jbinbfunc(op,a,b) ==>
      jl_call2_bool_wrapped_index(op, jlId(a), jlId(b))$Lisp

    0 == jlref("0.0+0im")
    1 == jlref("1.0+0im")

    x : % * a : Integer == jlref(concat [getind(x),"*",string(a)])
    x : Fraction(Integer) * y : % ==
      jlref(concat ["(",string(numer x), "//" , string(denom(x)) ")*", getind(y)])
    x : % * y : Fraction(Integer) ==
      jlref(concat [getind(x), "*(", string(numer(y)),"//", string(denom(y)), ")"])
    x :% / y : % == jbinfunc("/",x,y)
    x : % / i : Integer == jlref(concat [getind(x) , "/", string(i)])
    i : Integer / x : % == jlref(concat [string(i), "/", getind(x)])
    cis(x)   == junfunc("cis",x)
    cispi(x) == junfunc("cispi",x)
    jcfloat32(str) ==
      ret : % := jlref(str)
      jlType(ret) ~= "ComplexF32" => error "jcfloat32: not a Julia ComplexF32"
      ret

)abbrev domain JOBCF64 JLObjComplexF64
++ Convenience domain for Julia ComplexF64
++ Author: G.Vanuxem
++ Date Created: Aug. 2024
++ Description:
++  Convenience domain for Julia ComplexF64, objects that are used
++ within Julia, and not directly by the underlying FriCAS Common LISP.
++ It is not meant to be used directly, but rather for returned value
++ or function argument for example.
++ Only basic arithmetic operations are supported.
JLObjComplexF64() : Exports == Implementation where
  Exports ==> Join(JLObjectRing, Field) with
    "*" : (%, Integer) -> %
    ++ x*i is the multiplication by an integer.
    "/" : (%, Integer) -> %
    ++ x/i is the division by an integer.
    "/" : (Integer, %) -> %
    ++ i/x is the division of an integer by c
    jlApply : (String, %) -> %
    ++jlApply(func, x) applies the function func with x as parameter.
    jlApply : (String, %, %) -> %
    ++jlApply(func, x, y) applies the function func to x and y.
    jlApply : (String, %, %, %) -> %
    ++ jlApply(func, x, y, z) applies the function func to x,
    ++ y and z.
    cis : % -> %
    ++ cis(x) returns exp(%i*x) computed efficiently.
    cispi : % -> %
    ++ cispi(x) returns cis(%pi*x) computed efficiently.
    jcfloat64 : String -> %
    ++ jcfloat64(str) evaluates str in Julia and returns the Julia
    ++ Complex{Float64} object.
    ++ For example:
    ++ \example{jcfloat64 "cos(2pi)im"}
  Implementation ==> add
    import from JLUtilityFunctions
    import from String

    jlInitialize(true)
    Rep := SExpression

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func, a, b) ==> make_jlref_wcall2(func, a, b)$Lisp
    jbinbfunc(op,a,b) ==>
      jl_call2_bool_wrapped_index(op, jlId(a), jlId(b))$Lisp

    0 == jlref("0.0+0im")
    1 == jlref("1.0+0im")

    x : % * a : Integer == jlref(concat [getind(x),"*",string(a)])
    x : Fraction(Integer) * y : % ==
      jlref(concat ["(",string(numer x), "//" , string(denom(x)) ")*", getind(y)])
    x : % * y : Fraction(Integer) ==
      jlref(concat [getind(x), "*(", string(numer(y)),"//", string(denom(y)), ")"])
    x :% / y : % == jbinfunc("/",x,y)
    x : % / i : Integer == jlref(concat [getind(x) , "/", string(i)])
    i : Integer / x : % == jlref(concat [string(i), "/", getind(x)])
    cis(x)   == junfunc("cis",x)
    cispi(x) == junfunc("cispi",x)
    jcfloat64(str) ==
      ret : % := jlref(str)
      jlType(ret) ~= "ComplexF64" => error "jcfloat64: not a Julia ComplexF64"
      ret

)abbrev domain JOBI64 JLObjInt64
++ Convenience domain for Julia Int64
++ Author: G.Vanuxem
++ Date Created: Aug. 2024
++ Description:
++  Convenience domain for Julia Int64, objects that are used
++ within Julia, and not directly by the underlying FriCAS Common LISP.
++ It is not meant to be used directly, but rather for returned value
++ or function argument for example. Only basic arithmetic operations
++ are supported.
JLObjInt64() : Exports == Implementation where
  parsei    ==> PARSE_-INTEGER$Lisp
  Exports ==> Join(OrderedSet, JLObjectRing, CommutativeRing,
        EuclideanDomain, OrderedIntegralDomain) with
    jint64 : Integer -> %
    ++ jint64(i) returns i as a JLObjInt64.
    jint64 : String -> %
    ++ jint64(str) returns the Julia Int64 from the str command.
  Implementation ==> add
    import from JLUtilityFunctions
    import from String

    jlInitialize(true)
    Rep := SExpression

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func,a,b) ==> make_jlref_wcall2(func, a, b)$Lisp
    jbinbfunc(op,a,b) ==>
      jl_call2_bool_wrapped_index(op, jlId(a), jlId(b))$Lisp

    0 == jlref("0")
    1 == jlref("1")
    x < y  == jbinbfunc("<",x,y)
    x > y  == jbinbfunc(">",x,y)
    x >= y == jbinbfunc(">=",x,y)
    x <= y == jbinbfunc("<=",x,y)
    characteristic() == 0
    euclideanSize(x) ==
      x = 0 => error "euclideanSize called on zero"
      x < 0 => (- (parsei(string x) pretend Integer))::NonNegativeInteger
      parsei(string x)
    divide(a,b) ==
      ret : JLObjTuple := jbinfunc("divrem",a,b)
      [ret.1 pretend %, ret.2 pretend %]
    coerce(z : Integer) == jlref(string z)
    jint64(z : Integer) ==
      a := jlref(string z)
      jlType(a) = "Int64" => a
      error "jint64: not a Julia Int64"
    jint64(str : String) ==
      a := jlref(str)
      jlType(a) = "Int64" => a
      error "jint64: not a Julia Int64"

)abbrev domain JOBBINT JLObjBigInt
++ Convenience domain for Julia BigInt
++ Author: G.Vanuxem
++ Date Created: Aug. 2024
++ Description:
++  Convenience domain for Julia BigInt, objects that are used
++ within Julia, and not directly by the underlying FriCAS Common LISP.
++ It is not meant to be used directly, but rather for returned value
++ or function argument for example. It is also not meant to replace
++ NMInteger, which uses GMP, but basic arithmetic operations
++ are supported. Use the GMP library:
++ https://gmplib.org/
JLObjBigInt() : Exports == Implementation where
  parsei    ==> PARSE_-INTEGER$Lisp
  Exports ==> Join(OrderedSet, JLObjectRing, CommutativeRing,
        EuclideanDomain, OrderedIntegralDomain) with
    jlBICApply : (JLObjDynamicLinker, %) -> %
    ++ jlBICApply(func,x) applies the function pointer func to x.
    ++ It is expected that the C function modifies the first parameters
    ++ for the returned value (provided by FriCAS and returned here).
    jlBICApply : (JLObjDynamicLinker, %, %) -> %
    ++ jlBICApply(func,x,y) applies the function pointer func to x and y.
    ++ It is expected that the C function modifies the first parameters
    ++ for the returned value (provided by FriCAS and returned here).
    jlBICApply : (JLObjDynamicLinker, %, %, %) -> %
    ++ jlBICApply(func,x,y,z) applies the function pointer func to x, y and z.
    ++ It is expected that the C function modifies the first parameters
    ++ for the returned value (provided by FriCAS and returned here).
    jbigint : Integer -> %
    ++ jbigint(z) converts z to a Julia BigInt. 
    jbigint : String -> %
    ++ jbigint(z) returns the string str evaluated in Julia where the returned
    ++ value is assumed to be a Julia BigInt.
    ++ \example{jbigint "BigInt(1234567890)"}
  Implementation == add
    import from JLUtilityFunctions
    import from String

    jlInitialize(true)
    Rep := SExpression

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func,a,b) ==> make_jlref_wcall2(func, a, b)$Lisp
    jbinbfunc(op,a,b) ==>
      jl_call2_bool_wrapped_index(op, jlId(a), jlId(b))$Lisp

    0 == jlref("BigInt(0)")
    1 == jlref("BigInt(1)")

    x < y  == jbinbfunc("<",x,y)
    x > y  == jbinbfunc(">",x,y)
    x >= y == jbinbfunc(">=",x,y)
    x <= y == jbinbfunc("<=",x,y)

    euclideanSize(x) ==
      x = 0 => error "euclideanSize called on zero"
      x < 0 => (- parsei(string x) pretend Integer)::NonNegativeInteger
      (parsei(string x) pretend Integer)::NonNegativeInteger
    characteristic() == 0
    divide(a,b) ==
      ret : JLObjTuple := jbinfunc("divrem",a,b)
      [ret.1 pretend %, ret.2 pretend %]
    jlBICApply(func, x) ==
      ret := jlref("BigInt()")
      jlref(concat ["ccall(", getind(func),
       ", Int32, (Ref{BigInt}, Ref{BigInt}),", getind(ret),",", getind(x),")"])
      ret
    jlBICApply(func, x, y) ==
      ret := jlref("BigInt()")
      jlref(concat ["ccall(", getind(func),
        ", Int32, (Ref{BigInt}, Ref{BigInt}, Ref{BigInt}),", getind(ret), ",",
          getind(x), ",", getind(y), ")"])
      ret
    jlBICApply(func, x, y, z) ==
      ret := jlref("BigInt()")
      jlref(concat ["ccall(", getind(func), 
        ", Int32, (Ref{BigInt}, Ref{BigInt}, Ref{BigInt}),", getind(ret),",",
          getind(x), ",", getind(y), ",", getind(z),")"])
      ret
    coerce(z : Integer) == jlref(concat ["BigInt(",string(z),")"])
    jbigint(z : Integer) == jlref(concat ["BigInt(",string(z),")"])
    jbigint(str : String) == jlref(str)

)abbrev domain JOBPAIR JLObjPair
++ Convenience domain for Julia Pair.
++ Author: G.Vanuxem
++ Date Created: Dec. 2024
++ Description:
++  Convenience domain for Julia Pairs, objects that are used
++ within Julia, and not directly by the underlying FriCAS Common LISP.
++ It is not meant to be used directly, but rather for returned value
++ or function argument for example.
JLObjPair(F : JLObjectType, L : JLObjectType)
    : Exports == Implementation where
  Exports ==> JLObjectAggregate() with
    first  : % -> F
    ++ first(pair) returns the first element of pair.
    last : % -> L
    ++ last(pair) returns the last element of pair.
    jpair : String -> %
    ++ jpair(str) returns a Julia Pair
    ++ from the evaluation of the Julia command str.
  Implementation ==> add
    import from JLUtilityFunctions
    import from JLStringUtilities

    jlInitialize(true)
    Rep := SExpression
    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])   
    first(pair) : F == jlref(concat [getind(pair), "[1]" ])$F
    last(pair) : L == jlref(concat [getind(pair), "[2]" ])$L
    jpair(str : String) == jlref str

)abbrev domain JOBTPLE JLObjTuple
++ Convenience domain for Julia Tuple.
++ Author: G.Vanuxem
++ Date Created: Aug. 2024
++ Description:
++  Convenience domain for Julia Tuples, objects that are used
++ within Julia, and not directly by the underlying FriCAS Common LISP.
++ It is not meant to be used directly, but rather for returned value
++ or function argument for example.
JLObjTuple() : Exports == Implementation where
  Exports ==> JLObjectAggregate() with
    jtuple : List(Any) -> %
    ++ jtuple(lst) returns a Julia Tuple from the List lst.
    ++ lst must be compatible with 1D format.
    jtuple : String -> %
    ++ jtuple(str) returns a Julia Tuple
    ++ from the evaluation of the Julia command str.
  Implementation ==> add
    import from JLUtilityFunctions
    import from JLStringUtilities

    jlInitialize(true)
    Rep := SExpression

    jtuple(l : List(Any)) ==
      jlref(concat ["Tuple(",
        first lines formatExpression(l::OutputForm)$Format1D,")"])
    jtuple(str : String) == jlref str

)abbrev domain JOBDICT JLObjDict
++ Convenience domain for Julia Dict.
++ Author: G.Vanuxem
++ Date Created: Aug. 2024
++ Description:
++  Convenience domain for Julia Dictionaries, objects that are used
++ within Julia, and not directly by the underlying FriCAS Common LISP.
++ It is not meant to be used directly, but rather for returned value
++ or function argument for example.
JLObjDict() : Exports == Implementation where
  Exports ==> JLObjectAggregate() with
    elt : (%, Any) -> JLObject
    ++ elt(dict, key) returns the value associated to the key of dict.
    qelt : (%, Any) -> JLObject
    ++ qelt(dict, key) returns the value associated to the key of dict.
    ++ No checks are done regarding the existence of the key at
    ++ the FriCAS level. Returns the Julia missing value if the
    ++ key does not exist.
    elt : (%, JLSymbol) -> JLObject
    ++ elt(dict, sym) returns the value associated to the key sym of dict.
    qelt : (%, JLSymbol) -> JLObject
    ++ qelt(dict, sym) returns the value associated to the key sym of dict.
    ++ No checks are done regarding the existence of the key sym at
    ++ the FriCAS level. Returns the Julia missing value if the
    ++ key does not exist.
    setelt! : (%, Any, JLObject) -> %
    ++ setelt!(dict, key, val) sets the val to the key of dict.
    ++ If the key does not exist it will be created.
    setelt! : (%, JLSymbol, JLObject) -> %
    ++ setelt!(dict, key, val) sets the val to the key of dict.
    ++ If the key does not exist it will be created.  
    delete! : (%, Any) -> JLObject
    ++ delete!(dict, key) delete the mapping corresponding to the
    ++ the  key of dict.
    delete! : (%, JLSymbol) -> JLObject
    ++ delete!(dict, key) delete the mapping corresponding to the
    ++ the  key of dict.
    jdict : String -> %
    ++ jdict(str) returns a Julia Dict from the Julia command str.
  Implementation ==> add
    import from JLUtilityFunctions
    import from String

    jlInitialize(true)
    Rep := SExpression

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    elt(obj : %, jany : Any) ==
      key : String := first lines formatExpression(jany::OutputForm)$Format1D
      defined := concat(["haskey(", getind(obj), ",", key, ")"])
      not jlEvalString(defined)@Boolean =>
        error concat("elt: undefined symbol ", key)
      jlref(concat(["get(", getind(obj), ",", key, ", missing)"]))
    qelt(obj : %, jany : Any) ==
      key : String := first lines formatExpression(jany::OutputForm)$Format1D
      jlref(concat(["get(", getind(obj), ",", key, ", missing)"]))
    elt(obj : %, jsy : JLSymbol) ==
      defined := concat(["haskey(", getind(obj), ",",
        str := string(jsy), ")"])
      not jlEvalString(defined)@Boolean =>
        error concat("elt: undefined symbol ", str)
      jlref(concat(["get(", getind(obj), ",", string(jsy), ", missing)"]))
    qelt(obj : %, jsy : JLSymbol) ==
      jlref(concat(["get(", getind(obj), ",", string(jsy), ", missing)"]))
    setelt!(obj : %, jany : Any, val : JLObject) ==
      key : String := first lines formatExpression(jany::OutputForm)$Format1D
      jlref(concat(["setindex!(", getind(obj), ",",
        getind(val) , "," , key, ")"]))
    setelt!(obj : %, jsy : JLSymbol, val : JLObject) ==
      jlref(concat(["setindex!(", getind(obj), ",",
        getind(val) , "," , string(jsy), ")"]))
    delete!(obj : %, jany : Any) ==
      key : String := first lines formatExpression(jany::OutputForm)$Format1D
      jlref(concat(["delete!(", getind(obj), ",", key, ")"]))
    delete!(obj : %, jsy : JLSymbol) ==
      jlref(concat(["delete!(", getind(obj), ",", string(jsy), ")"]))
    jdict(str : String) == jlref str
      
)abbrev domain JFLOAT JLFloat
++ Domain for Julia (Big) floats
++ Author: G. Vanuxem
++ Date Created: Feb. 2024
++ Keywords: float, floating point, number
++ Description:
++  \spadtype{JLFloat} implements arbitrary precision floating
++  point arithmetic using Julia BigFloats. Use the MPFR library:
++ https://www.mpfr.org/
JLFloat() : Exports == Implementation where
  INT       ==> Integer
  JI64      ==> JLInt64
  PI        ==> PositiveInteger
  NNI       ==> NonNegativeInteger
  JF64      ==> JLFloat64
  parsei    ==> PARSE_-INTEGER$Lisp
  Exports ==> Join(JLObjectRing, FloatingPointSystem, arbitraryPrecision,
            ElementaryFunctionCategory, TranscendentalFunctionCategory,
            DifferentialRing) with
            -- SpecialFunctionCategory) with
    jlApprox?: (%, %) -> Boolean
    ++ jlApprox?(x,y) computes inexact equality comparison
    ++ with default parameters.
    ++ Two numbers compare equal if their relative distance
    ++ or their absolute distance is within tolerance bounds.
    jlApprox?: (%, %, %) -> Boolean
    ++ jlApprox?(x,y,atol) computes inexact equality comparison
    ++ with absolute tolerance atol.
    ++ Two numbers compare equal if their relative distance
    ++ or their absolute distance is within tolerance bounds.
    finite?   : % -> Boolean
    ++ finite?(x) tests whether or not x is finite.
    integer?  : % -> Boolean
    ++ integer?(x) tests whether or not x is an integer.
    precision : % -> PositiveInteger
    ++ precision(x) returns the precision of x.
    precision: (%, PI) -> %
    ++ precision(x, p) returns a copy of x with precision p.
    jlApply : (String, %) -> %
    ++jlApply(func, x) applies the function func with x as parameter.
    jlApply : (String, %, %) -> %
    ++jlApply(func, x, y) applies the function func to x and y.
    jlApply : (String, %, %, %) -> %
    ++ jlApply(func, x, y, z) applies the function func to x,
    ++ y and z.
    jlMPFRApply : (JLObject, %) -> %
    ++ jlMPFRApply(func,x) applies the function pointer func to x.
    ++ It is expected that the C function modifies the first parameters
    ++ for the returned value (provided by FriCAS and returned here) and
    ++ and as a last parameter, the rounding mode. See MPFR.
    ++ Uses Julia rounding mode, default to nearest.
    ++ \example{mpfr:=jlDlOpen "libmpfr"}
    ++ \example{sym:= jlDlSym(mpfr,jsym(mpfr_gamma))}
    ++ \example{val:=jfloat("0.7");}
    ++ \example{jlMPFRApply(sym,val)}
    ++ => 1.29805533264755778568117117915281161778...
    ++ \example{jlDlClose(mpfr)}
    jlMPFRApply : (JLObject, %, %) -> %
    ++ jlMPFRApply(func,x,y) applies the function pointer func to x and y.
    ++ It is expected that the C function modifies the first parameters
    ++ for the returned value (provided by FriCAS and returned here) and
    ++ and as a last parameter, the rounding mode. See MPFR.
    ++ Uses Julia rounding mode, default to nearest.
    ++ \example{mpfr:=j lDlOpen "libmpfr"}
    ++ \example{sym:= jlDlSym(mpfr,jsym(mpfr_pow))}
    ++ \example{val:=jfloat("0.7");}
    ++ \example{jlMPFRApply(sym,val, jfloat(2))}
    ++ \example{jlDlClose(mpfr)}
    jlMPFRApply : (JLObject, %, %, %) -> %
    ++ jlMPFRApply(func,x,y,z) applies the function pointer func to x, y and z.
    ++ It is expected that the C function modifies the first parameters
    ++ for the returned value (provided by FriCAS and returned here) and
    ++ as a last parameter, the rounding mode (the default mode is used here).
    ++ See MPFR.
    ++ Uses Julia rounding mode, default to nearest.
    ++ \example{mpfr:=j lDlOpen "libmpfr"}
    ++ \example{sym:= jlDlSym(mpfr,jsym(mpfr_fma))}
    ++ \example{val:=jfloat("0.7");}
    ++ \example{jlMPFRApply(sym,val, jfloat(2), jfloat(5))}
    ++ \example{jlDlClose(mpfr)}
    expm1   :  % -> %
    ++ expm1(x) computes accurately â¯^x-1. It avoids the loss of precision
    ++ involved in the direct evaluation of exp(x)-1 for small values of x.
    exp2  : % -> %
    ++ exp2(x) computes the base 2 exponential of x.
    exp10 : % -> %
    ++ exp10(x) computes the base 10 exponential of x. 
    log1p : % -> %
    ++log1p(x) computes accurately log(1+x)
    log2  : % -> %
    ++ log2(x) computes the base 2 logarithm of x.
    log10 : % -> %
    ++ log10(x) computes the base 10 logarithm of x.  
    exp    : () -> %
    ++ exp() returns the JLFloat â¯ (%e or exp(1)).
    exp1    : () -> %
    ++ exp1() returns the JLFloat â¯ (%e or exp(1)).
    cis : % -> JLComplexFloat
    ++ cis(x) returns exp(%i*x) computed efficiently.
    cispi : % -> JLComplexFloat
    ++ cispi(x) returns cis(%pi*x) computed efficiently.
    urand01 : () -> %
    ++ urand01() returns an uniformly distributed random number
    ++ contained in [0,1].
    nrand : () -> %
    ++ nrand() returns an normally distributed random number.
    atan : (%, %) -> %
    ++ atan(x, y) computes the inverse tangent of x/y.
    "*"      : (%, Integer) -> %
    ++ x*i is the multiplication by an integer.
    "/"      : (Integer, %) -> %
    ++ i/x is the division of an integer by x.
    "^"      : (%, Fraction(Integer)) -> %
    ++ x^q is the exponentiation by a Fraction(Integer).
    coerce   : JF64 -> %
    ++ coerce(x) coerces x to a JLFloat.
    ++ convenience function.
    coerce   : Float -> %
    ++ coerce(x) coerces x to JLFLoat.
    jfloat   : String -> %
    ++ jfloat(z) returns z as a JFLoat.
    ++ For example where automatic coercions is also used:
    ++ \example{sqrt(jfloat(2.0)^2+7.0^2+9.^2)}
    jfloat   : Integer -> %
    ++ jfloat(z) returns z as a JFLoat.
    ++ For example:
    ++ \example{sqrt(jfloat(2)^2+7.0^2+9.^2)}
    jfloat   : Fraction(Integer) -> %
    ++ jfloat(q) returns z as a JFLoat.
    jfloat   : Float -> %
    ++ jfloat(x) returns x as a JFLoat.
  Implementation ==> add
    import from JLUtilityFunctions
    import from String
    import from NMInteger
    import from NMFraction(NMInteger)

    jlInitialize(true)
    Rep := SExpression

    -- For direct access to MPFR via C call (LLVM)
    jlEvalString("using Base.MPFR: MPFRRoundingMode, ROUNDING_MODE")@Void

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func,a,b) ==> make_jlref_wcall2(func, a, b)$Lisp
    junbfunc(bfunc, a) ==> jl_call1_bool_wrapped_index(bfunc, jlId(a))$Lisp
    jbinbfunc(op,a,b) ==>
      jl_call2_bool_wrapped_index(op, jlId(a), jlId(b))$Lisp

    precision() == jlEvalString("precision(BigFloat)")@PI
    precision(p : PI) ==
      oldp := precision()
      jlEvalString(concat(["setprecision(BigFloat,",string(p),")"]))@Void
      oldp
    precision(x : %) == jlEvalString(concat(["precision(", getind(x),")"]))
    precision(x : %, p : PI) ==
      tmp : String := concat(["setprecision(", getind(x),",", string(p),")"])
      jlref(tmp)
    bits() == jlEvalString("precision(BigFloat)")@PI
    bits(n) ==
      jlEvalString(concat ["setprecision(BigFloat,",
        string(n), ")"])@PI

    0         == jlref("zero(BigFloat)")
    1         == jlref("one(BigFloat)")
    pi()      == jlref("BigFloat(Ï)")
    exp1()    == jlref("BigFloat(â¯)")
    exp()    == jlref("BigFloat(â¯)")
    urand01() == jlref("rand(BigFloat)")
    nrand()   == jlref("randn(BigFloat)")

    x < y  == jbinbfunc("<",x,y)
    x > y  == jbinbfunc(">",x,y)
    x >= y == jbinbfunc(">=",x,y)
    x <= y == jbinbfunc("<=",x,y)
    jlApprox?(x, y) == jbinbfunc("isapprox",x,y)
    jlApprox?(x, y, atol) ==
      jlEvalString(concat(["isapprox(", getind(x),
        ",", getind(y), ", atol=", getind(atol),")"]))

    finite? x == junbfunc("isfinite",x)
    integer? x == junbfunc("isinteger",x)

    x : % / y : % == jbinfunc("/", x, y)
    x : % ^ y : % == jbinfunc("^", x, y)
    x : % * y : Integer == jbinfunc("*", x, coerce(y)@JLObjBigInt)
    x : Fraction(Integer) * y : % ==
      jlref(concat ["(",string(numer x), "//" , string(denom(x)) ")*", getind(y)])
    x : % * y : Fraction(Integer) ==
      jlref(concat [getind(x), "*(", string(numer(y)),"//", string(denom(y)), ")"])
    x : Integer / y : % == jbinfunc("/", coerce(x)@JLObjBigInt, y)
    x : % / y : Integer == jbinfunc("/", x, coerce(y)@JLObjBigInt)
    x ^ y : PI == jbinfunc("^", x, coerce(y)@JLObjBigInt)
    x ^ y : NNI == jbinfunc("^", x, coerce(y)@JLObjBigInt)
    x ^ y : Integer == jbinfunc("^", x, coerce(y)@JLObjBigInt)
    x : % ^ y : Fraction(Integer) ==
      jlref(concat [getind(x),"^(", string(numer(y)), "//",
        string(denom(y)),")"])

    -- x quo y == jbinfunc("div", x, y)
    x quo y == jbinfunc("Ã·", x, y)
    x rem y == jbinfunc("%", x, y)
    fractionPart(x) ==
      ret : JLObjTuple := junfunc("modf",x)
      qelt(ret,1) pretend %
    wholePart(x) ==
      ret : JLObjTuple := junfunc("modf",x)
      parsei toString(junfunc("BigInt", qelt(ret,2)))
    float(m, e, b) == jbinfunc("*",jfloat(m), jfloat(b)^e)

    jlApply(func, x) : % == make_jlref_wcall1(func, x)$Lisp
    jlApply(func, x, y) : % == make_jlref_wcall2(func, x, y)$Lisp
    jlApply(func, x, y, z) : % == make_jlref_wcall3(func, x, y, z)$Lisp

    jlMPFRApply(func, x) ==
      ret := jlref("BigFloat()")
      jlref(concat ["ccall(", getind(func),
        ", Int32, (Ref{BigFloat}, Ref{BigFloat}, Int32),", getind(ret),",",
          getind(x),", ROUNDING_MODE[])"])
      ret
    jlMPFRApply(func, x, y) ==
      ret := jlref("BigFloat()")
      jlref(concat ["ccall(", getind(func),
        ", Int32, (Ref{BigFloat}, Ref{BigFloat}, Ref{BigFloat}, Int32),",
          getind(ret), ",", getind(x), ",", getind(y), ", ROUNDING_MODE[])"])
      ret
    jlMPFRApply(func, x, y, z) ==
      ret := jlref("BigFloat()")
      jlref(concat ["ccall(", getind(func), 
        ", Int32, (Ref{BigFloat}, Ref{BigFloat}, Ref{BigFloat}, Ref{BigFloat}, Int32),",
          getind(ret), ",", getind(x), ",", getind(y), ",", getind(z), ", ROUNDING_MODE[])"])
      ret

    sqrt(x)  == junfunc("â",x)
    exp(x)   == junfunc("exp",x)
    log(x)   == junfunc("log",x)
    expm1(x) == junfunc("expm1",x)
    exp2(x)  == junfunc("exp2",x)
    exp10(x) == junfunc("exp10",x)
    log1p(x) == junfunc("log1p",x)
    log2(x)  == junfunc("log2",x)
    log10(x) == junfunc("log10",x)

    sin(x)  == junfunc("sin",x)
    cos(x)  == junfunc("cos",x)
    tan(x)  == junfunc("tan",x)
    sec(x)  == junfunc("sec",x)
    cot(x)  == junfunc("cot",x)
    csc(x)  == junfunc("csc",x)

    asin(x)  == junfunc("asin",x)
    acos(x)  == junfunc("acos",x)
    atan(x)  == junfunc("atan",x)
    atan(x,y) == jbinfunc("atan", x, y)
    asec(x)  == junfunc("asec",x)
    acot(x)  == junfunc("acot",x)
    acsc(x)  == junfunc("acsc",x)

    sinh(x)  == junfunc("sinh",x)
    cosh(x)  == junfunc("cosh",x)
    tanh(x)  == junfunc("tanh",x)
    sech(x)  == junfunc("sech",x)
    coth(x)  == junfunc("coth",x)
    csch(x)  == junfunc("csch",x)

    asinh(x)  == junfunc("asinh",x)
    acosh(x)  == junfunc("acosh",x)
    atanh(x)  == junfunc("atanh",x)
    asech(x)  == junfunc("asech",x)
    acoth(x)  == junfunc("acoth",x)
    acsch(x)  == junfunc("acsch",x)

    cis(x)   == junfunc("cis",x)
    cispi(x) == junfunc("cispi",x)

    convert(x : %) : Float ==
      tmp := jlref(concat(["QQ(rationalize(BigInt,",
        getind(x),"))"]))$NMFraction(NMInteger)
      coerce(retract(tmp)@Fraction(Integer))
    retractIfCan(x) : Union (Integer, "failed") ==
      integer?(x) => convert jlref(concat(["ZZ(", getind(x),")"]))$NMInteger
      "failed"
    retractIfCan(x) : Union (Fraction(Integer), "failed") ==
      tmp := jlref(concat(["QQ(rationalize(BigInt,",
        getind(x),"))"]))$NMFraction(NMInteger)
      coerce(retract(tmp)@Fraction(Integer))

    coerce(jf : JF64) : % == jfloat(convert(jf)@String)
    coerce(i : Integer) : % == jlref(concat(["BigFloat(", string(i),")"]))
    coerce(x : Float) : % ==
      tmp := outputSpacing(0)
      ret : % := jlref(concat(["BigFloat(_"", convert(x)@String, "_")"]))
      outputSpacing(tmp)
      ret
    coerce(fi: Fraction(Integer)) == coerce(numer(fi))/coerce(denom(fi))
    coerce(f : %) : OutputForm == string(f) pretend OutputForm
    jfloat(s : String) : % == jlref(concat(["BigFloat(_"", s,"_")"]))
    jfloat(i : Integer) : % == jlref(concat(["BigFloat(", string(i),")"]))
    jfloat(fi : Fraction(Integer)) == coerce(fi)
    jfloat(x : Float) : % == coerce(x)

)abbrev domain JCFLOAT JLComplexFloat
++ Domain for Julia (Big) complex floats
++ Author: G. Vanuxem
++ Date Created: May. 2024
++ Keywords: float, floating point, complex number
++ Description:
++  \spadtype{JLFComplexloat} implements arbitrary precision floating
++  point arithmetic for complex numbers using Julia BigFloats (MPFR based).
++ https://www.mpfr.org/
JLComplexFloat() : Exports == Implementation where
  INT       ==> Integer
  JI64      ==> JLInt64
  PI        ==> PositiveInteger
  NNI       ==> NonNegativeInteger
  JF64      ==> JLFloat64
  Exports ==> Join(JLObjectRing, ComplexCategory(JLFloat)) with
    jlApprox?: (%, %) -> Boolean
    ++ jlApprox?(x,y) computes inexact equality comparison
    ++ with default parameters.
    ++ Two numbers compare equal if their relative distance
    ++ or their absolute distance is within tolerance bounds.
    jlApprox?: (%, %, %) -> Boolean
    ++ jlApprox?(x,y,atol) computes inexact equality comparison
    ++ with absolute tolerance atol.
    ++ Two numbers compare equal if their relative distance
    ++ or their absolute distance is within tolerance bounds.
    finite?   : % -> Boolean
    ++ finite?(x) tests whether or not x is finite.
    integer?  : % -> Boolean
    ++ integer?(x) tests whether or not x is an integer.
    real?  : % -> Boolean
    ++ real?(x) tests whether or not x is real.
    precision : % -> PositiveInteger
    ++ precision(x) returns the precision of x.
    precision: (%, PI) -> %
    ++ precision(x, p) returns a copy of x with precision p.
    jlApply : (String, %) -> %
    ++jlApply(func, x) applies the function func with x as parameter.
    jlApply : (String, %, %) -> %
    ++jlApply(func, x, y) applies the function func to x and y.
    jlApply : (String, %, %, %) -> %
    ++ jlApply(func, x, y, z) applies the function func to x,
    ++ y and z.
    expm1   :  % -> %
    ++ expm1(x) computes accurately â¯^x-1. It avoids the loss of precision
    ++ involved in the direct evaluation of exp(x)-1 for small values of x.
    exp2  : % -> %
    ++ exp2(x) computes the base 2 exponential of x.
    exp10 : % -> %
    ++ exp10(x) computes the base 10 exponential of x. 
    log1p : % -> %
    ++log1p(x) computes accurately log(1+x)
    log2  : % -> %
    ++ log2(x) computes the base 2 logarithm of x.
    log10 : % -> %
    ++ log10(x) computes the base 10 logarithm of x.  
    exp  : () -> %
    ++ exp() returns the JLComplexFloat â¯ (%e or exp(1)).
    exp1  : () -> %
    ++ exp1() returns the JLComplexFloat â¯ (%e or exp(1)).
    cis : % -> %
    ++ cis(x) returns exp(%i*x) computed efficiently.
    cispi : % -> %
    ++ cispi(x) returns cis(%pi*x) computed efficiently.
    urand01 : () -> %
    ++ urand01() returns an uniformly distributed random number
    ++ contained in [0,1].
    nrand : () -> %
    ++ nrand() returns an normally distributed random number.
    atan : % -> %
    ++ atan(x) computes the inverse tangent of x.
    atan : (%, %) -> %
    ++ atan(x, y) computes the inverse tangent of x/y.
    "*"      : (%, Integer) -> %
    ++ c*i is the multiplication by an integer.
    "/"      : (Integer, %) -> %
    ++ i/c is the division of and integer by c.
    "/"      : (%, Integer) -> %
    ++ c/i is the division by an integer.
    coerce   : JF64 -> %
    ++ coerce(r) coerces r to a JLComplexFloat.
    coerce   : Float -> %
    ++ coerce(r) coerces to a JLComplexFloat.
    jcfloat   : Integer -> %
    ++ jcfloat(z) returns z as a JLComplexFloat.
    jcfloat   : Fraction(Integer) -> %
    ++ jcfloat(q) returns q as a JLComplexFloat.
    jcfloat   : Float -> %
    ++ jcfloat(r) returns r as a JLComplexFloat.
    -- TODO jcfloat(string) 
  Implementation ==> add
    import from JLUtilityFunctions
    import from String
    import from NMInteger
    import from NMFraction(NMInteger)

    jlInitialize(true)
    Rep := SExpression
    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])

    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func, a, b) ==> make_jlref_wcall2(func, a, b)$Lisp
    junbfunc(bfunc, a) ==> jl_call1_bool_wrapped_index(bfunc, jlId(a))$Lisp
    jbinbfunc(op,a,b) ==>
      jl_call2_bool_wrapped_index(op, jlId(a), jlId(b))$Lisp

    0           == jlref("zero(Complex{BigFloat})")
    1           == jlref("one(Complex{BigFloat})")
    imaginary() == jlref("Complex{BigFloat}(im)")
    pi()        == jlref("Complex{BigFloat}(Ï)")
    exp1()      == jlref("Complex{BigFloat}(â¯)")
    exp()       == jlref("Complex{BigFloat}(â¯)")
    urand01()   == jlref("rand(Complex{BigFloat})")
    nrand()     == jlref("randn(Complex{BigFloat})")
    real(x)     == make_jlref_wcall1("real",x)$Lisp
    imag(x)     == make_jlref_wcall1("imag",x)$Lisp

    complex(r, i) ==
      jlref(concat(["Complex{BigFloat}(", getind(r), ",", getind(i), ")"]))
    jlApprox?(x, y) == jbinbfunc("isapprox",x,y)
    jlApprox?(x, y, atol) ==
      jlEvalString(concat(["isapprox(", getind(x),
        ",", getind(y), ", atol=", getind(atol),")"]))

    finite? x == junbfunc("isfinite",x)
    integer? x == junbfunc("isinteger",x)
    real? x == junbfunc("isreal",x)

    zero?(x) == junbfunc("iszero", x)
    one?(x) == junbfunc("isone", x)
    x + y == jbinfunc("+", x, y)
    x - y == jbinfunc("-", x, y)
    - x   == junfunc("-", x)
    x : % * y : % == jbinfunc("*", x, y)
    x : NMInteger * y : % == jbinfunc("*", x, y)
    x : Integer * y : % == jlref(concat([string(x), "*", getind(y)]))
    x : PositiveInteger * y : % == jlref(concat([string(x), "*", getind(y)]))
    x : NonNegativeInteger * y : % == jlref(concat([string(x), "*", getind(y)]))
    x ^ y : PositiveInteger == jlref(concat [getind(x), "^", string(y)])
    x ^ y : NonNegativeInteger == jlref(concat [getind(x), "^", string(y)])
    x : % / y : % == jbinfunc("/", x, y)
    x : % ^ y : % == jbinfunc("^", x, y)
    x : % * y : Integer == jbinfunc("*", x, coerce(y)@JLObjBigInt)
    x : Fraction(Integer) * y : % ==
      jlref(concat ["(",string(numer x), "//" , string(denom(x)) ")*", getind(y)])
    x : % * y : Fraction(Integer) ==
      jlref(concat [getind(x), "*(", string(numer(y)),"//", string(denom(y)), ")"])
    x : Integer / y : % == jlref(concat([getind(coerce(x)), "/", getind(y)]))
    x : % / y : Integer == jlref(concat([getind(x), "/", getind(coerce(y))]))
    x ^ y : PI == jbinfunc("^", x, coerce(y)@JLObjBigInt)
    x ^ y : NNI == jbinfunc("^", x, coerce(y)@JLObjBigInt)
    x ^ y : Integer == jbinfunc("^", x, coerce(y)@JLObjBigInt)
    x : % ^ y : Fraction(Integer) ==
      jlref(concat [getind(x),"^(", string(numer(y)), "//",
        string(denom(y)),")"])

    jlApply(func, x) : % == make_jlref_wcall1(func, x)$Lisp
    jlApply(func, x, y) : % == make_jlref_wcall2(func, x, y)$Lisp
    jlApply(func, x, y, z) : % == make_jlref_wcall3(func, x, y, z)$Lisp

    -- x quo y == jbinfunc("div", x, y)
    x quo y == jbinfunc("Ã·", x, y)
    x rem y == jbinfunc("%", x, y)

    sqrt(x)  == junfunc("â",x)
    exp(x)   == junfunc("exp",x)
    log(x)   == junfunc("log",x)
    expm1(x) == junfunc("expm1",x)
    exp2(x)  == junfunc("exp2",x)
    exp10(x) == junfunc("exp10",x)
    log1p(x) == junfunc("log1p",x)
    log2(x)  == junfunc("log2",x)
    log10(x) == junfunc("log10",x)

    sin(x)  == junfunc("sin",x)
    cos(x)  == junfunc("cos",x)
    tan(x)  == junfunc("tan",x)
    sec(x)  == junfunc("sec",x)
    cot(x)  == junfunc("cot",x)
    csc(x)  == junfunc("csc",x)

    asin(x)  == junfunc("asin",x)
    acos(x)  == junfunc("acos",x)
    atan(x)  == junfunc("atan",x)
    atan(x,y) == jbinfunc("atan", x, y)
    asec(x)  == junfunc("asec",x)
    acot(x)  == junfunc("acot",x)
    acsc(x)  == junfunc("acsc",x)

    sinh(x)  == junfunc("sinh",x)
    cosh(x)  == junfunc("cosh",x)
    tanh(x)  == junfunc("tanh",x)
    sech(x)  == junfunc("sech",x)
    coth(x)  == junfunc("coth",x)
    csch(x)  == junfunc("csch",x)

    asinh(x)  == junfunc("asinh",x)
    acosh(x)  == junfunc("acosh",x)
    atanh(x)  == junfunc("atanh",x)
    asech(x)  == junfunc("asech",x)
    acoth(x)  == junfunc("acoth",x)
    acsch(x)  == junfunc("acsch",x)

    cis(x)   == junfunc("cis",x)
    cispi(x) == junfunc("cispi",x)

    urand01() == jlref("rand(Complex{BigFloat})")
    nrand()   == jlref("randn(Complex{BigFloat})")

    retractIfCan(x) : Union (Integer, "failed") ==
      integer?(x) => convert jlref(concat(["ZZ(", getind(x),")"]))$NMInteger
      "failed"
    retractIfCan(x) : Union (Fraction(Integer), "failed") ==
      tmp := jlref(concat(["QQ(rationalize(BigInt,",
        getind(x),"))"]))$NMFraction(NMInteger)
      coerce(retract(tmp)@Fraction(Integer))

    coerce(jf : JF64) : % == jlref(concat(["Complex{BigFloat}(", convert(jf),")"]))
    coerce(i : Integer) : % == jlref(concat(["Complex{BigFloat}(", string(i),")"]))
    coerce(x : Float) : % == 
      jlref(concat(["Complex{BigFloat}(", getind(coerce(x)@JLFloat), ")"]))
    coerce(fi: Fraction(Integer)) == coerce(numer(fi))/coerce(denom(fi))
    coerce(cplx) : OutputForm == string(cplx) pretend OutputForm
    jcfloat(i : Integer) : % == jlref(concat(["Complex{BigFloat}(", string(i),")"]))
    jcfloat(fi : Fraction(Integer)) == coerce(fi)
    jcfloat(x : Float) : % == coerce(x)

)abbrev domain JDFRAME JLDataFrame
++ Description: Julia DataFrames support
++ Author: G. Vanuxem
++ Date Created: May. 2024
++ Keywords: tabular data, sciences, statistics, description
++ Description:
++  \spadtype{JLDataFrame} adds support of the DataFrames.jl
++  Julia package. As of now, most of its use has to be done in
++  a generic manner using jlApply.
-- Report results for example. 
JLDataFrame() : Exports == Implementation where
  PI  ==> PositiveInteger
  NNI ==> NonNegativeInteger
  Z   ==> Integer
  getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
  Exports ==> JLObjectAggregate() with
    --elt : (%, JLSymbol) -> JLVector(JLObject)
    --++ elt(obj, sym) returns the property sym of obj.
    --qelt : (%, JLSymbol) -> JLVector(JLObject)
    --++ elt(obj, sym) returns the property sym of obj. No checks are done
    --++ regarding the existence of the sym property. If it does not exist,
    --++ Julia will throw an error.
    --elt : (%, Integer) -> JLVector(JLObject)
    --++ elt(obj, ind) returns the element at index ind of obj.
    --++ For example for a Tuple or a vector.
    --qelt : (%, Integer) -> JLVector(JLObject)
    --++ qelt(obj, ind) returns the element at index ind of obj.
    --++ For example for a Tuple or a vector.
    jlDescribe: % -> %
    ++ jlDescribe(df) returns basic statistics about df.
    matrix : % -> JLObject
    ++ matrix(df) returns a copy of the internal DataFrame matrix.
    jdframe:  JLFloat64Matrix -> %
    ++ jdframe(array) returns an automatically created data frame.
    jdframe:  (JLFloat64Matrix, List(JLSymbol)) -> %
    ++ jdframe(a, ls) returns a data frame from data a and column names
    ++ ls.
  Implementation ==> add
    import from JLUtilityFunctions
    import from String

    not jlUsing "DataFrames,Statistics" =>
      error "JLDataFrame: DataFrames is not installed in Julia"
    -- jlEvalString("macro dfa(obj) DataFrame(eval(Meta.parse(obj)),:auto) end")@Void
  
    Rep := SExpression
    jlEvalString("function dfa(obj) DataFrame(obj, :auto) end")@Void

    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp

    elt(obj : %, jsy : JLSymbol) ==
      defined := concat(["hasproperty(", getind(obj), ",",
        str := string(jsy), ")"])
      not jlEvalString(defined)@Boolean =>
        error concat("elt: undefined symbol ", str)
      jlref(concat(["getproperty(", getind(obj), ",", string(jsy), ")"]))
    qelt(obj : %, jsy : JLSymbol) ==
      jlref(concat(["getproperty(", getind(obj), ",", string(jsy), ")"]))
    elt(obj : %, ind : Integer) ==
      jlref(concat([getind(obj), "[!,", string(ind), "]"]))
    qelt(obj : %, ind : Integer) ==
      jlref(concat([getind(obj), "[!,", string(ind), "]"]))
    jlDescribe(df) == junfunc("describe", df)
    matrix(df) == junfunc("Matrix", df)
    jdframe(array) ==
      junfunc("dfa", coerce(array)$JLMatrix(JLObjFloat64))
    jdframe(array, lnames) ==
      tls := first lines formatExpression(lnames::OutputForm)$Format1D
      jlref(concat(["DataFrame(",
        getind(coerce(array)$JLMatrix(JLObjFloat64)),",", tls, ")"]))

)abbrev domain JVECTOR JLVector
++ Description: This domain provides a JLVector type
++ for JLObjectType. Minimum index is 1.
JLVector(R : JLObjectType) : Exports == Implementation where
  PI  ==> PositiveInteger
  NNI ==> NonNegativeInteger
  Z   ==> Integer
  Exports ==> Join(JLObjectAggregate, JLVectorCategory(R)) with
    vector  : List R -> %
    ++ vector(l) converts the list l to a vector.
    elt : (%, PositiveInteger) -> R
    ++ elt(v,n) returns the element in v from the index n. 
    qelt : (%, PositiveInteger) -> R
    ++ qelt(v,n) returns the element in v from the index n.
    ++ No checks are done at the FriCAS level, only at the
    ++ Julia level
    if not R has NMType then
      kroneckerProduct : (%, %) -> %
      ++ kroneckerProduct(v1,v2) returns the kronecker product of v1 and v2.
      if R has Join(JLObjectRing, FloatingPointSystem,
            arbitraryPrecision) then
        urand01 : (n : PI) -> JLVector(JLFloat)
        ++ urand01(n) returns a JLVector of size n with 
        ++ uniformly distributed random numbers contained in [0,1].
        nrand : (n : PI) -> JLVector(JLFloat)
        ++ nrand(n) returns a JLVector of size n with normally
        ++ distributed random numbers.
      if R has Join(JLObjectRing, ComplexCategory(JLFloat)) then
        urand01 : (n : PI) -> JLVector(JLComplexFloat)
        ++ urand01(n) returns a JLVector of size n with 
        ++ uniformly distributed random numbers contained in [0,1].
        nrand : (n : PI) -> JLVector(JLComplexFloat)
        ++ nrand(n) returns a JLVector of size n with normally
        ++ distributed random numbers.
    coerce  : JLFloat64Vector -> JLVector(JLObjFloat64)
    ++ coerce(x): convenience function.
    coerce  : JLComplexF64Vector -> JLVector(JLObjComplexF64)
    ++ coerce(x): convenience function.
    jvector:    String -> %
    ++ jvector(str) evaluates the string str and returns the generated vector.
    ++ No checks are done at the FriCAS level.
  Implementation ==> Vector(R) add
    import from JLUtilityFunctions
    import from String

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func, a, b) ==> make_jlref_wcall2(func, a, b)$Lisp

    jlInitialize(true)
    Rep := SExpression

    #x == jlEvalString(concat(["length(", getind(x),")"]))
    minIndex x == 1$Lisp
    maxIndex x ==
      jlEvalString(concat(["length(", getind(x),")"]))
    new(n, x:R) ==
      jlref(concat(["fill(", getind(x),",", string(n),")"]))
    qelt(x, i : PositiveInteger) ==
      jlref(concat([getind(x),"[",string(i),"]"]))$R
    qelt(x, i : Integer) ==
      jlref(concat([getind(x),"[",string(i),"]"]))$R
    elt(x, i : Integer) : R ==
      i > #x => error "elt$JLvector: incompatible index"
      jlref(concat([getind(x),"[",string(i),"]"]))$R
    elt(x, i : PositiveInteger) : R ==
      i > #x => error "elt$JLvector: incompatible index"
      jlref(concat([getind(x),"[",string(i),"]"]))$R
    qsetelt!(v : %, i, s:R) ==
      jlEvalString(concat([getind(v),"[",string(i), "]=", getind(s)]))@Void
      s
    setelt!(v : %, i : Integer, s : R) ==
      i > #v => error "setelt!$JLvector: incompatible index"
      jlEvalString(concat([getind(v),"[",string(i), "]=", getind(s)]))@Void
      s
    fill!(v, x) == jbinfunc("fill!", v, x)
    less?(v,n) == #v < n
    vector l == construct l

    x + y == jbinfunc("+", x, y)
    x - y == jbinfunc("-", x, y)
    - x   == junfunc("-", x)
    a : R * v : % == jbinfunc("*", a, v)
    v : % * a : R == jbinfunc("*", v, a)
    x : Integer * y : % == jlref(concat([string(x), "*", getind(y)]))

    if R is JLFloat then
      urand01(n) : JLVector(JLFloat) ==
        jlref(concat(["rand(BigFloat,", string(n), ")"]))
      nrand(n) : JLVector(JLFloat) ==
        jlref(concat(["randn(BigFloat,", string(n), ")"]))
    if R is JLComplexFloat then
      urand01(n) : JLVector(JLComplexFloat) ==
        jlref(concat(["rand(Complex{BigFloat},", string(n), ")"]))
      nrand(n) : JLVector(JLComplexFloat)  ==
        jlref(concat(["randn(Complex{BigFloat},", string(n), ")"]))

    map!(f, s1 : %) ==
      n : Z := #s1
      for i in 1..n repeat qsetelt!(s1, i, f(qelt(s1, i)))
      s1

    map(f, s1 : %) ==
      n := #s1
      ss2 : % := new(n, qelt(s1,1))
      for i in 1..n repeat qsetelt!(ss2, i, f(qelt(s1, i)))
      ss2

    map(f, a, b)   ==
      maxind := min(#a, #b)
      c : % := new(maxind, qelt(a,1))
      for i in 1..maxind repeat
        setelt!(c, i, f(qelt(a, i), qelt(b, i)))
      c

    kroneckerProduct(v1,v2) == jbinfunc("kron",v1,v2)
    copy(v) == junfunc("deepcopy", v)
    sort(v : %) == junfunc("sort",v)
    sort!(v : %) == junfunc("sort!",v)
    
    coerce(v : JLFloat64Vector) ==
      make_jlref_from_vec(0$NNI, v)$Lisp
    coerce(v : JLComplexF64Vector) ==
      make_jlref_from_vec(1$NNI, v)$Lisp
    coerce(v : %) : OutputForm == coerce(v pretend JLObject)
    jvector(str) == jlref(str)

)abbrev package JVECTOR2 JLVectorFunctions2
++ Author:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   This package provides operations which all take as arguments
++ Julia vectors of elements of some type \spad{A} and functions from \spad{A} to
++ another of type \spad{B}. The operations all iterate over their vector argument
++ and either return a value of type B or a vector over B.
JLVectorFunctions2(A, B) : Exports == Implementation where
  A, B : JLObjectRing --Temporary
  VA ==> JLVector A
  VB ==> JLVector B
  O2 ==> FiniteLinearAggregateFunctions2(A, VA, B, VB)
  UB ==> Union(B,"failed")
  Exports ==> with
    scan   : ((A, B) -> B, VA, B) -> VB
      ++ scan(func, vec, ident) creates a new vector whose elements are
      ++ the result of applying reduce to the binary function func,
      ++ increasing initial subsequences of the vector vec,
      ++ and the element ident.
    reduce : ((A, B) -> B, VA, B) -> B
      ++ reduce(func, vec, ident) combines the elements in vec using the
      ++ binary function func. Argument ident is returned if vec is empty.
    map    : (A -> B, VA) -> VB
      ++ map(f, v) applies the function f to every element of the vector v
      ++ producing a new vector containing the values.
    map : (A -> UB, VA) -> Union(VB,"failed")
      ++ map(f, v) applies the function f to every element of the vector v
      ++ producing a new vector containing the values or \spad{"failed"}.
  Implementation ==> add
    scan(f, v, b)   == scan(f, v, b)$O2
    reduce(f, v, b) == reduce(f, v, b)$O2
    map(f : (A -> B), v : VA) : VB == map(f, v)$O2

    map(f:(A -> UB), a:VA):Union(VB,"failed") ==
     res : List B  := []
     for u in entries(a) repeat
       r := f u
       r = "failed" => return "failed"
       res := cons(r::B, res)
     vector reverse! res

)abbrev domain JMATRIX JLMatrix
++ Description: This domain provides a generic Julia matrix type
++ stored in Julia with no bound checking on elt's. Minimum index is 1.
++ Beware, for matrix with Nemo elements, contrary to Julia matrix,
++ Nemo follows the convention of the C libraries, it wraps and uses
++ row major representation.
++ See:
++ https://nemocas.github.io/Nemo.jl/stable/developer/interfaces/#Column-major-vs-row-major-matrices
++ for more information.
-- TODO: to be improved for partially implemented JLObjectType
JLMatrix(R : JLObjectRing) :  Exports == Implementation where
  PI      ==> PositiveInteger
  NNI     ==> NonNegativeInteger
  INT     ==> Integer
  NINT    ==> NMInteger
  Row     ==> JLVector(R)
  Col     ==> JLVector(R)
  MLAF    ==> MatrixLinearAlgebraFunctions(R, Row, Col, %)
  parsei  ==> PARSE_-INTEGER$Lisp
  Exports ==> Join(JLObjectAggregate,
                JLMatrixCategory(R, Row, Col)) with
    new : (NNI, NNI, R) -> %
    ++ new(m, n, x) creates a matrix of size m by n with all elements x.
    if R has NMRing and (R has IntegerNumberSystem or
        R has QuotientFieldCategory(NINT)) then
      radicalEigenvalues: % -> JLVector(NMAlgebraicNumber)
      ++ radicalEigenvalues(mat) returns a Julia vector containing
      ++ the eigenvalues of mat.
      radicalEigenvaluesWithMultiplicities : % -> JLVector(JLObjTuple)
      ++ radicalEigenvaluesWithMultiplicities(mat) returns a Julia vector
      ++ containing Julia tuples of the eigenvalues and their multiplicities.
      ++ The tuples are of internal type (NMAlgebraicNumber, JLObjInt64).
    if R has ComplexCategory(NMRealField) then
      eigenvalues: % -> JLVector(R)
      ++ eigenvalues(m) returns eigenvalues of m.
    if R has IntegralDomain then
      invertIfCan : % -> Union(%,"failed")
      ++ invertIfCan(m) returns the inverse of the matrix m.
      ++ If the matrix is not invertible, "failed" is returned.
      ++ Error: if the matrix is not square.
    if not R has NMType then
      jlApprox?: (%, %) -> Boolean
      ++ jlApprox?(A,B) computes component-wise inexact equality
      ++ with default parameters.
      ++ Two numbers compare equal if their relative distance
      ++ or their absolute distance is within tolerance bounds.
      if R has Join(JLObjectRing, FloatingPointSystem,
          arbitraryPrecision) then
        urand01 : (m : PI, n : PI) -> JLMatrix(JLFloat)
        ++ urand01(m,n) returns a JLMatrix of size (m,n) with 
        ++ uniformly distributed random number contained in [0,1].
        ++ \example{mat := urand01(4,4)$JLMatrix(JLFloat)}
        ++ \example{qr := jlApply("qr", mat)}
        ++ \example{qr.Q * qr.R}
        nrand : (m : PI, n : PI) -> JLMatrix(JLFloat)
        ++ nrand(m,n) returns a JLMatrix of size (m,n) with normally
        ++ distributed random numbers. For example:
        ++ \example{mat := nrand(4,4)$JLMatrix(JLFloat)}
        ++ \example{chol := jlApply("cholesky", mat * transpose(mat))}
        ++ \example{chol.L * chol.U}
      if R has Join(JLObjectRing, ComplexCategory(JLFloat)) then
        urand01 : (m : PI, n : PI) -> JLMatrix(JLComplexFloat)
        ++ urand01(m,n) returns a JLMatrix of size (m,n) with 
        ++ uniformly distributed random number contained in [0,1].
        ++ \example{mat := urand01(4,4)$JLMatrix(JLComplexFloat)}
        ++ \example{qr := jlApply("qr", mat)}
        ++ \example{qr.Q * qr.R}
        nrand : (m : PI, n : PI) -> JLMatrix(JLComplexFloat)
        ++ nrand(m,n) returns a JLMatrix of size (m,n)
        ++ with normally distributed random numbers.
        ++ \example{mat := nrand(4,4)$JLMatrix(JLComplexFloat)}
        ++ \example{qr := jlApply("qr", mat)}
        ++ \example{qr.Q * qr.R}
    inverse : % -> %
    ++ inverse(m) returns inverse matrix. Throws a Julia error if m
    ++ is no invertible.
    trace : % -> R
    ++ trace(m) returns the trace of square matrix m.
    ++ Julia error if m is not square.
    identity:    NNI -> %
    ++ identity(n) returns a n by n identity matrix.
    diagonalMatrix:   JLVector(R) -> %
    ++ diagonalMatrix(v) returns a diagonal matrix with elements of v.
    coerce: % -> Matrix(R)
    ++ coerce(m) coerces a copy of m to a Matrix(R).
    coerce  : JLFloat64Matrix -> JLMatrix(JLObjFloat64)
    ++ coerce(x): convenience function.
    coerce  : JLComplexF64Matrix -> JLMatrix(JLObjComplexF64)
    ++ coerce(x): convenience function.
    coerce  : JLFloat32Matrix -> JLMatrix(JLObjFloat32)
    ++ coerce(x): convenience function.
    coerce  : JLComplexF32Matrix -> JLMatrix(JLObjComplexF32)
    ++ coerce(x): convenience function.
    factorize : JLMatrix(JLObjFloat32) -> JLObject
    ++ factorize(m) factorizes m using a suited matrix factorization for m.
    ++ For a symmetric matrix the Bunch-Kaufman factorization will be choosen
    ++ whereas for generic matrices, a LU or a QR factorization will be used.
    factorize : JLMatrix(JLObjComplexF32) -> JLObject
    ++ factorize(m) factorizes m using a suited matrix factorization for m.
    ++ For a symmetric matrix the Bunch-Kaufman factorization will be choosen
    ++ whereas for generic matrices, a LU or a QR factorization will be used.
    factorize : JLMatrix(JLObjFloat64) -> JLObject
    ++ factorize(m) factorizes m using a suited matrix factorization for m.
    ++ For a symmetric matrix the Bunch-Kaufman factorization will be choosen
    ++ whereas for generic matrices, a LU or a QR factorization will be used.
    factorize : JLMatrix(JLObjComplexF64) -> JLObject
    ++ factorize(m) factorizes m using a suited matrix factorization for m.
    ++ For a symmetric matrix the Bunch-Kaufman factorization will be choosen
    ++ whereas for generic matrices, a LU or a QR factorization will be used.
    jmatrix:    String -> %
    ++ jmatrix(str) evaluates the string str and returns the generated matrix.
    ++ No checks are done at the FriCAS level.
  Implementation ==> add --Matrix(R) add
    import from JLUtilityFunctions
    import from String

    jlInitialize(true)
    op_of_Ring : Symbol := CAR(devaluate(R)$Lisp)$Lisp

    Rep := SExpression

    NRing : String := string(op_of_Ring)

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func, a ,b) ==> make_jlref_wcall2(func, a, b)$Lisp
    jbinbfunc(op,a,b) ==>
      jl_call2_bool_wrapped_index(op, jlId(a), jlId(b))$Lisp

    if R has NMRing then
      new(rows, cols, a : R) ==
        jlref(concat(["matrix_space(", jlNMRing()$R ,",",
          string(rows), ",", string(cols),")(fill(", getind(a), ",(",
            string(rows), ",", string(cols),")))"]))
    else
      new(rows, cols, a : R) ==
        jlref(concat(["fill(", getind(a), ",(", 
          string(rows), ",", string(cols),"))"]))

    symmetric?(m) == junfunc("issymmetric",m)

    minRowIndex x == 1
    minColIndex x == 1
    nrows(a : %) : NNI ==
      jlEvalString(concat(["size(", getind(a), ",1)"]))
    ncols(a : %) : NNI ==
      jlEvalString(concat(["size(", getind(a), ",2)"]))
    maxRowIndex x == nrows(x)
    maxColIndex x == ncols(x)
    #m == nrows(m) * ncols(m)
    
    qelt(m, i, j) == jlref(concat(["getindex(", getind(m), ",",
      string(i), ",", string(j), ")"]))$R
    elt(m : %, i : INT, j : INT) ==
      i > nrows(m) or j > ncols(m) =>
        error "elt$JLMatrix: incompatible index"
      jlref(concat(["getindex(", getind(m), ",",
        string(i), ",", string(j), ")"]))$R
    qsetelt!(m, i:INT, j:INT, r) ==
      jlEvalString(concat(["setindex!(", getind(m), ",", getind(r)
        ",", string(i), ",", string(j), ")"]))@Void
      r
    setelt!(m : %, i : Integer, j : Integer, r : R) ==
      i > nrows(m) or j > ncols(m) =>
        error "setelt!$JLMatrix: incompatible index"
      jlEvalString(concat(["setindex!(", getind(m), ",", getind(r)
        ",", string(i), ",", string(j), ")"]))@Void
      r
    row(m, i) ==
      jlref(concat([getind(m),"[",string(i),",:]"]))$JLVector(R)
    column(m,i) ==
      jlref(concat([getind(m),"[:,",string(i),"]"]))$JLVector(R)
    

    fill!(v, x) == jbinfunc("fill!", v, x)
    vertConcat(m1,m2) == jbinfunc("vcat", m1, m2)
    horizConcat(m1,m2) == jbinfunc("hcat", m1, m2)
    vertConcat(m1,m2) == jbinfunc("vcat", m1, m2)
    swapRows!(m, i, j) == 
      jlref(concat ["swap_rows!(",getind(m),",",string(i),",",string(j),")"])
    swapColumns!(m, i, j) == 
      jlref(concat ["swap_cols!(",getind(m),",",string(i),",",string(j),")"])
  
    qnew(rows, cols) == new(rows, cols, 0$R)
    zero(m,n) == new(m, n, 0$R)
    x + y == jbinfunc("+", x, y)
    x - y == jbinfunc("-", x, y)
    - x   == junfunc("-", x)
    x : % * y : % == jbinfunc("*", x, y)
    a : R * m : % == jbinfunc("*", a, m)
    m : % * a : R == jbinfunc("*", m, a)
    m : % / a : R == jbinfunc("/", m, a)
    x : Integer * y : % == jlref(concat([string(x), "*", getind(y)]))

    if not R has NMRing then
      kroneckerProduct(m1,m2) == jbinfunc("kron",m1,m2)
      jlApprox?(x, y) == jbinbfunc("isapprox",x,y)
      if R is JLFloat then
        urand01(rows, cols) : JLMatrix(JLFloat) ==
          jlref(concat(["rand(BigFloat,", string(rows), ",", string(cols),")"]))
        nrand(rows, cols) : JLMatrix(JLFloat) ==
          jlref(concat(["randn(BigFloat,", string(rows), ",", string(cols),")"]))
      if R is JLComplexFloat then
        urand01(rows, cols) : JLMatrix(JLComplexFloat) ==
          jlref(concat(["rand(Complex{BigFloat},", string(rows), ",",
            string(cols),")"]))
        nrand(rows, cols) : JLMatrix(JLComplexFloat) ==
          jlref(concat(["randn(Complex{BigFloat},", string(rows), ",",
            string(cols),")"]))
    else if R is NMInteger or R is NMFraction(NMInteger) then
      radicalEigenvalues(m) == jlref(concat ["eigenvalues(QQBar,",
        getind(m), ")"])$JLVector(NMAlgebraicNumber)
      radicalEigenvaluesWithMultiplicities(m) ==
        jlref(concat ["eigenvalues_with_multiplicities(QQBar,",
          getind(m), ")"])$JLVector(JLObjTuple)

    square?(m) == nrows(m) = ncols(m)
    zero?(m) == jlEvalString(concat(["iszero(", getind(m), ")"]))
    diagonal?(m) == jlEvalString(concat(["is_diagonal(", getind(m), ")"]))
    symmetric?(m) == jlEvalString(concat(["is_symmetric(", getind(m), ")"]))
    --positiveDefinite?(m : %) : Boolean ==
    --   jl_bool_2dfunction(0$NNI,"isposdef", m.elts, m.ncols)$Lisp

    copy(m) == junfunc("deepcopy", m)
    transpose(m) == junfunc("transpose", m)
    
    if R has IntegralDomain then
      if R is JLFloat or R is JLComplexFloat then
        rank(m) == rank(m)$MLAF
      else
        rank(m) == parsei string junfunc("rank", m)
      nullity(m) == nullity(m)$MLAF
      nullSpace(m) == nullSpace(m)$MLAF
      invertIfCan(m) == invertIfCan(m)$MLAF
    if R has EuclideanDomain then
      rowEchelon(m) == rowEchelon(m)$MLAF

    if R has Field then
      inverse(m) : % == make_jlref_wcall1("inv", m)$Lisp

    if R is JLObjInt64 then -- returns a Julia Float64 so convert it
      determinant(m) == jlref(concat(["Int64(det(", getind(m),"))"]))$R
    else if R is JLObjBigInt then
      determinant(m) == jlref(concat(["BigInt(det(", getind(m),"))"]))$R
    else
      determinant(m) == jlref(concat(["det(", getind(m),")"]))$R
    minordet(m) == minordet(m)$MLAF
    trace(m) == make_jlref_wcall1("tr", m)$Lisp

    identity(n) ==
        m := new(n,n, 0$R)
        for i in 1..n repeat setelt!(m,i,i,1$R)
        m
    
    diagonalMatrix(v : JLVector(R)) : % ==
      n : NNI := #v
      u := new(n, n, 0$R)
      for i in 1..n repeat setelt!(u, i, i, elt(v,i))
      u

    factorize(m : JLMatrix(JLObjFloat32)) == junfunc("factorize", m)
    factorize(m : JLMatrix(JLObjComplexF32)) == junfunc("factorize", m)
    factorize(m : JLMatrix(JLObjFloat64)) == junfunc("factorize", m)
    factorize(m : JLMatrix(JLObjComplexF64)) == junfunc("factorize", m)

    matrix(l : List List R) ==
      empty?(l) => error "matrix: empty matrix is not supported"
      -- error check: this is a top level function
      rows : NonNegativeInteger := 1; cols := # first l
      for ll in rest l repeat
        cols ~= # ll => error "matrix: rows of different lengths"
        rows := rows + 1
      ans := new(rows, cols, 0$R)
      for i in 1..rows for ll in l repeat
        for j in 1..cols for r in ll repeat
          qsetelt!(ans, i, j, r)
      ans

    coerce(m : %) : Matrix(R) ==
      l : List List R
      l := [[qelt(m, j, i) _
          for i in 1 .. ncols(m)] _
          for j in 1 .. nrows(m)]
      matrix l

    coerce(m : JLFloat32Matrix) : JLMatrix(JLObjFloat32) ==
      make_jlref_from_fmat(0$NNI, jlVector(m), nrows m)$Lisp
    coerce(m : JLComplexF32Matrix) : JLMatrix(JLObjComplexF32) ==
      make_jlref_from_fmat(1$NNI, jlVector(m), nrows m)$Lisp
    coerce(m : JLFloat64Matrix) : JLMatrix(JLObjFloat64) ==
      make_jlref_from_mat(0$NNI, jlVector(m), nrows m)$Lisp
    coerce(m : JLComplexF64Matrix) : JLMatrix(JLObjComplexF64) ==
      make_jlref_from_mat(1$NNI, jlVector(m), nrows m)$Lisp
    coerce(m : %) : OutputForm == coerce(m pretend JLObject)
    jmatrix(str) == jlref(str)

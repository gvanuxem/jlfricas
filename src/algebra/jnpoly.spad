)abbrev domain NUP NMUnivariatePolynomial
++ Univariate polynomial domain using the Nemo Julia package
++ Author: G. Vanuxem
++ Date Created: March, 2024
++ Nested polynomials Fatemans's benchmark:
++ \example{R:=NUP(NINT,'x)}
++ \example{x:=x::R}
++ \example{RR := NUP(R,'y)}
++ \example{y:=y::RR}
++ \example{RRR := NUP(RR,'z)}
++ \example{z:=z::RRR}
++ \example{T:=NUP(RRR,'t)}
++ \example{t:=t::T}
++ \example{f := 1 + x + y + z + t}
++ \example{p :=  f^30;}
++ \example{)set message time on}
++ \example{p*(p + 1);}
-- TODO: eval, elt, subst, compose, evaluate (elt???)
NMUnivariatePolynomial(R : NMRing, x : Symbol):
      Exports == Implementation where
  NINT      ==> NMInteger
  NRAT      ==> NMFraction(NMInteger)
  JI64      ==> JLInt64
  INT       ==> Integer
  PI        ==> PositiveInteger
  NNI       ==> NonNegativeInteger
  SUP       ==> SparseUnivariatePolynomial(R)
  parsei    ==> PARSE_-INTEGER$Lisp
  Exports ==> Join(NMCommutativeRing,
      UnivariatePolynomialCategory(R)) with
    constant? : % -> Boolean
    ++ constant?(p) checks whether or not p is a constant polynomial.
    monomial? : % -> Boolean
    ++ monomial?(p) checks whether or not p is a monomial.
    monomialRecursive? : % -> Boolean
    ++ monomialRecursive?(p) checks whether or not p is
    ++ monomial recurisvely (all scalar types).
    term? : % -> Boolean
    ++ term?(p) checks whether or not p is a one term polynomial.
    termRecursive? : % -> Boolean
    ++ termRecursive?(p) checks whether or not p as one term,
    ++ recursively (all scalar types).
    monic? : % -> Boolean
    ++ monic?(p) checks whether or not p  monic.
    square? : % -> Boolean
    ++ square?(p) checks whether or not p is a perfect square.
    if R has IntegerNumberSystem or R has
        Algebra(NMFraction(NMInteger)) then
      minimalPolynomial : NMAlgebraicNumber -> %
      ++ minimalPolynomial(algn) returns the minimal polynomial of algn.
      ++ Convenience function.
      roots : % -> JLVector(NMAlgebraicNumber)
      ++ roots(p) returns the roots of p.
      ++ Convenience function.
    if R has IntegerNumberSystem then
      cyclotomicPolynomial : (NNI, %) -> %
      ++ cyclotomicPolynomial(n,p) returns the n-th
      ++ cyclotomic polynomial Φn.
      ++ For example:
      ++ \example{x:=x::NUP(NINT,'x)}
      ++ \example{cyclotomicPolynomial(15,x)}
      swinnertonDyerPolynomial : (NNI, %) -> %
      ++ swinnertonDyerPolynomial(n, p) returns the Swinnerton-Dyer
      ++ polynomial Sn.
      ++ \example{x:=x::NUP(NINT,'x)}
      ++ \example{swinnertonDyerPolynomial(4,x)}
      cosMinimalPolynomial : (NNI, %) -> %
      ++ cosMinimalPolynomial(n,p) returns the minimal polynomial
      ++ of 2*cos(2*π/n).
      thetaQExp : (INT, PI, %) -> %
      ++ thetaQExp(r,n,p) returns the q-expansion to length n
      ++ of the Jacobi theta function raised to the power r, ϑ(q)^r.
      etaQExp : (INT, PI, %) -> %
      ++ etaQExp(r,n,p) returns the q-expansion to length n
      ++ of the Dedekind eta function (without the leading factor
      ++ q^(1/ 24)) raised to the power r, (q^(−1/24)*η(q))^r.
    if R has Algebra(NMFraction(NMInteger)) then
      "+" : (%, Fraction(Integer)) -> %
      ++ p * q is the sum of p and a rational number q (Fraction(Intger))
      "*" : (%, Fraction(Integer)) -> %
      ++ p * q is the product of p with a rational
      ++ number q (Fraction(Integer))
      "+" : (Fraction(Integer), %) -> %
      ++ q * p is the sum of p and a rational number q (Fraction(Intger))
      "*" : (Fraction(Integer), %) -> %
      ++ q * p is the product of p with a rational
      ++ number q (Fraction(Integer))
    "*"   : (%, NNI) -> %
    ++ p * n is the product of p with a non negative integer.
    "*"   : (%, PI) -> %
    ++ p * n is the product of p with a positive integer.
    divide : (%, %) -> Record(quotient: %, remainder : %)
    ++ divide(p,q) returns a record (quotient, remainder) of the
    ++ the Euclidean division of p by q.
    _quo : (%, %) -> %
    ++ a quo b returns the quotient of \spad{a} and b, forgetting
    ++ the remainder.
    _rem : (%, %) -> %
    ++ a rem b returns the remainder of \spad{a} and b.
    exactDivide : (%, %) -> %
    ++ exactDivide(p,q) divides p by q if the division is exact.
    pseudoDivide : (%, %) -> Record(quotient : %, remainder : %)
    ++ pseudoDivide(p1,p2) returns pseudo-quotient and
    ++ pseudo-remainder of the pseudo-division of p1 by p2.
    jnup  : UnivariatePolynomial(x, R) -> %
    ++ jnup(p) converts the univariate polynomial p to
    ++ a Nemo univariate polynomial.
    compose : (%, %) -> %
    ++ compose(p, q) returns the composition p(q(x)).
    factor   : % -> NMFactored(%)
    ++ factor(p) returns the factorization of p using the
    ++ NMFactored domain.
    length   : % -> NNI
    ++ length(p) returns the number of coefficients
    ++ in its dense representation. It includes zero coefficients.
    trailingCoefficient : % -> R
    ++ trailingCoefficient(p) returns the trailing coefficientof p.
    constantCoefficient : % -> R
    ++ constantCoefficient(p) returns the constant of p.
    truncate : (%, NNI) -> %
    ++ truncate(p, n) return p truncated to n term. It's the remainder
    ++ of the division by x^n.
    mullow : (%, %, NNI) -> %
    ++ mullow(p1,p2,n) is the truncated multiplication of p1 and p2 by n.
    reverse : % -> %
    ++ reverse the coefficients of p (the leading becomes the trailing)
    ++ and normalise the resulting polynomial.
    reverse : (%, NNI) -> %
    ++ reverse the coefficients of p (the leading becomes the trailing)
    ++ and normalise the resulting polynomial. Adjust the length to n so
    ++ the resulting polynomial is truncated or padded with zeroes before
    ++ the leading term if necessary
    shiftLeft : (%, NNI) -> %
    ++ shiftLeft(p) left shift p.
    shiftRight : (%, NNI) -> %
    ++ shiftRight(p) right shift p.
    shiftLeft! : (%, NNI) -> %
    ++ shiftLeft(p) left shift p.
    shiftRight! : (%, NNI) -> %
    ++ shiftRight(p) right shift p.
    coerce   : Variable(x) -> %
    ++ coerce(x) converts the variable x to a Nemo univariate polynomial.
  Implementation ==> add
    import from JLUtilityFunctions
    import from JLStringUtilities

    jlInitialize(true)
    Rep := SExpression

    tmp : SExpression := devaluate(R)$Lisp
    op_of_Ring : Symbol := CAR(tmp)$Lisp

    NRing : String := string(op_of_Ring)
    NUPRing := concat(["UP",FORMAT(false, "~a", tmp)$Lisp, string(x)])
    NUPRing := jlRegexReplace(NUPRing,jlRegex("[(|)|\s]"),
      jlSubstitute(""))

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func,a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func,a,b) ==> make_jlref_wcall2(func, a, b)$Lisp
    junbfunc(bfunc, a) ==> jl_call1_bool_wrapped_index(bfunc, jlId(a))$Lisp
    jbinbfunc(op,a,b) ==>
      jl_call2_bool_wrapped_index(op, jlId(a), jlId(b))$Lisp

    strToPoly(s : String) : Union(Polynomial(Fraction Integer), "failed") ==
      jlRegexMatch?(s, jlRegex("[\[|{|O]")) => "failed"
      str := concat("0$Polynomial(Fraction Integer)+", s)
      af := parse(str)$InputForm
      av := interpret_in_new_env(af)$InputForm
      retractIfCan(av)$AnyFunctions1(Polynomial(Fraction Integer))

    -- Set up the ring
    tuple : Boolean := jbinbfunc("isa", jobject(jlNMRing()$R)$JLObject,
      jobject("Tuple")$JLObject)
    if tuple then
      jlEvalString(concat([NUPRing,"=polynomial_ring(",
        jlNMRing()$R, "[1],_"", string(x), "_")"]))
    else
      jlEvalString(concat([NUPRing,"=polynomial_ring(",
        jlNMRing()$R, ",_"", string(x), "_")"]))

    if R is NMInteger then
      roots(p) ==
        jlref(concat(["roots(QQBar,",
          getind(p),")"]))$JLVector(NMAlgebraicNumber)
      minimalPolynomial(p : NMAlgebraicNumber) : % ==
        jlref(concat(["minpoly(", NUPRing, "[1],", getind(p),")"]))
      cyclotomicPolynomial(n,p) ==
        jlref(concat ["cyclotomic(",string(n),",", getind(p),")"])
      swinnertonDyerPolynomial(n,p) ==
        jlref(concat ["swinnerton_dyer(",string(n),",", getind(p),")"])
      cosMinimalPolynomial(n,p) ==
        jlref(concat ["cos_minpoly(",string(n),",", getind(p),")"])
      thetaQExp(r,n,p) ==
        jlref(concat ["theta_qexp(",string(r),",", string(n), ",", getind(p),")"])
      etaQExp(r,n,p) ==
        jlref(concat ["eta_qexp(",string(r),",", string(n), ",", getind(p),")"])
    else if R is NMFraction(NMInteger) then
      roots(p) ==
        jlref(concat(["roots(QQBar,",
          getind(p),")"]))$JLVector(NMAlgebraicNumber)
      minimalPolynomial(p : NMAlgebraicNumber) : % ==
        jlref(concat(["minpoly(", NUPRing, "[1],", getind(p),")"]))
      p : % + q : Fraction(Integer) == jbinfunc("+", p, coerce(q)@NRAT)
      p : % * q : Fraction(Integer) == jbinfunc("*", p, coerce(q)@NRAT)
      q : Fraction(Integer) + p : % == jbinfunc("+", coerce(q)@NRAT, p)
      q : Fraction(Integer) * p : % == jbinfunc("*", coerce(q)@NRAT, p)
      (p / q) : % == jbinfunc("/" ,p, q)

    jnup(up) : % ==
      p: String := first(lines formatExpression(up::OutputForm)$Format1D)
      ret := jlRegexReplace(p, jlRegex("/"), jlSubstitute("//"))
      jlref(ret)

    jlNMRing() == NUPRing
    jlObject() == jlEvalString(concat(["string(", NUPRing,")"]))@String

    0 == jlref(concat(["zero(", NUPRing, "[1])"]))
    1 == jlref(concat(["one(", NUPRing, "[1])"]))
    one?(p) == junbfunc("isone",p)
    zero?(p) == junbfunc("iszero",p)
    constant?(p) == junbfunc("is_constant",p)
    monomial?(p) == junbfunc("is_monomial",p)
    monomialRecursive?(p) == junbfunc("is_monomial_recursive",p)
    term?(p) == junbfunc("is_term",p)
    termRecursive?(p) == junbfunc("is_term_recursive",p)
    unit?(p) == junbfunc("is_unit",p)
    monic?(p) == junbfunc("is_monic",p)
    square?(p) == junbfunc("is_square",p)

    a : R * b : % == jbinfunc("*",a,b)
    a : % * b : R == jbinfunc("*",a,b)
    i : INT  * b : % == jlref(concat [string(i),"*" ,getind(b)])
    a : % * i : INT  == jlref(concat [getind(a),"*" , string(i)])
    i : NNI  * b : % == jlref(concat [string(i),"*" ,getind(b)])
    a : % * i : NNI  == jlref(concat [getind(a),"*" , string(i)])
    i : PI  * b : % == jlref(concat [string(i),"*" ,getind(b)])
    a : % * i : PI == jlref(concat [getind(a),"*" , string(i)])
    a : % ^ i : PI  == jlref(concat [getind(a),"^", string(i)])
    a : % ^ i : NNI  == jlref(concat [getind(a),"^", string(i)])
    exactDivide(p,q) == jbinfunc("divexact", p, q)

    monomial(c : R, n : NonNegativeInteger) : % ==
      jlref(concat(["monomial(", getind(c::%), ",", string(n), ")"]))

    constructOrdered(terms : List Record(k: NonNegativeInteger, c: R)) : % ==
      res : % := 0
      for t in terms repeat
        res := res + monomial(t.c, t.k)
      res

    construct(terms) == constructOrdered(terms)

    (p1:% exquo p2:%) ==
      ret : JLObjTuple := jbinfunc("divides", p1, p2)
      not jlEvalString(concat(["first(", getind(ret), ")"]))@Boolean
        => "failed"
      junfunc("last", ret)@%
    a:% quo b:% == jbinfunc("div", a, b)
    a:% rem b:% == jbinfunc("mod", a, b)
    pseudoRemainder(p1,p2) == jbinfunc("pseudorem",p1,p2)
    pseudoDivide(p1,p2) : Record(quotient : %, remainder : %) ==
      divrem := jlref(concat ["pseudodivrem(", getind(p1),
        ",", getind(p2),")"])$JLObject
      [qelt(divrem,1) pretend %, qelt(divrem, 2) pretend %]
    if R has DivisionRing then
      recip(p) ==
        ret : JLObjTuple := jbinfunc("divides", 1, p)
        not jlEvalString(concat(["first(", getind(ret), ")"]))@Boolean
          => "failed"
        junfunc("last", ret)@%
      p/(r : R) == inv(r)*p
      unitNormal(p) ==
        unitC : R := junfunc("canonical_unit", p)
        a := inv unitC
        [unitC::%, p * a , a::%]
      unitCanonical(p) ==
        a : R := junfunc("canonical_unit", p)
        p * inv a
    else
      recip(p) ==
        unit?(p) => p
        "failed"
    characteristic() ==
      jlEvalString(concat(["characteristic(", NUPRing,"[1])"]))
    monomial(coef,exp) ==
      jlref(concat([getind(coef),"*", string(x), "^",
        string(exp pretend Integer)]))
    reductum(p) == junfunc("tail",p)
    gcd(p1,p2)  == jbinfunc("gcd",p1,p2)
    lcm(p1,p2)  == jbinfunc("lcm",p1,p2)
    content(p : %)  == jlref(concat(["content(", getind(p), ")"]))$R
    primitivePart(p) == junfunc("primpart", p)
    discriminant(p) == junfunc("discriminant", p)
    length(p) == parsei(string(junfunc("length", p)))
    factor(p : %) : NMFactored(%) == factor(p)$NMFactored(%)
    factor(p : %) : Factored(%) == factor(p)$NMFactored(%)

    -- Using Nemo factorisation (can be different; over rationals for example)
    -- unit(p) == unit factor(p)

    coefficient(p : %, n : NNI) ==
      jlref(concat ["coeff(", getind(p),",", string(n), ")"])$R
    leadingCoefficient(p : %) ==
      junfunc("leading_coefficient", p)
    trailingCoefficient(p) ==
      jlref(concat ["trailing_coefficient(", getind(p),")"])$R
    constantCoefficient(p) ==
      jlref(concat ["constant_coefficient(", getind(p),")"])$R
    degree(p) == jlEvalString(concat(["degree(", getind(p),")"]))@NNI
    minimumDegree(p) ==
      jlEvalString(concat(["findfirst(!iszero, _
        collect(coefficients(",getind(p),")))-1"]))@NNI
    leadingTerm(p) ==
      ind := getind(p)
      deg : NNI := parsei(string jlref(concat ["degree(", ind,")"])) 
      [deg, jlref(concat ["leading_coefficient(", ind,")"])$R]
    listOfTerms(p) ==
      ind := getind(p)
      v : JLVector(R) := jlref(concat ["reverse(collect(coefficients(",ind, ")))"]) 
      ret : List(Record(k:NNI, c:R)) := []
      for i in 0..(#v-1) repeat 
        if not zero?(coef := qelt(v,i+1)) then
          ret := concat(ret, [(#v-i-1) pretend NNI, coef])
      ret
    truncate(p,n) ==
      jlref(concat ["truncate(", getind(p),",", string(n),")"])
    mullow(p1, p2, n) ==
      jlref(concat ["mullow(", getind(p1),",", getind(p2) , ",", string(n),")"])
    reverse(p) == junfunc("reverse",p)
    reverse(p,n) == jlref(concat ["reverse(", getind(p),",", string(n),")"])
    shiftLeft(p,n) == jlref(concat ["shift_left(", getind(p),",", string(n),")"])
    shiftRight(p,n) == jlref(concat ["shift_right(", getind(p),",", string(n),")"])
    shiftLeft!(p,n) == jlref(concat ["shift_left!(", getind(p),",", string(n),")"])
    shiftRight!(p,n) == jlref(concat ["shift_right!(", getind(p),",", string(n),")"])

    elt(p, at : R) : R == jbinfunc("evaluate",p,at)
    compose(p, q) ==
      jlref(concat ["compose(", getind(p),",", getind(q),",inner=:second)"])$%
    differentiate(p) == junfunc("derivative",p)
    integrate(p) == junfunc("integral", p)
    coerce(v : Variable(x)) == jlref(concat(NUPRing,"[2]"))
    coerce(i : Integer) == jlref(concat([NUPRing,"[1](",string(i),")"]))
    coerce(c : R) ==  jlref(concat([NUPRing,"[1](",getind(c),")"]))
    coerce(p : %) : OutputForm ==
      --outputForm(listOfTerms(p) pretend SUP, outputForm x) -- too expensive
      str := jlRegexReplace(string(p), jlString("//"),jlString("/"))
      (ret := strToPoly(str)) case "failed" => str pretend OutputForm
      coerce(ret)

)abbrev domain NULP NMUnivariateLaurentPolynomial
++ Univariate laurent polynomial domain using the AbstractAlgebra Julia package
++ Author: G. Vanuxem
++ Date Created: Dec, 2024
-- TODO: eval, elt, subst, compose, evaluate
-- TODO: *term*, truncate, mullow, *degree, reverse, integrate,
-- constantMonomial checks
--   with other Nemo ring than NINT an NRAT to see if they
--   should be removed or rewrited. See commented out implementations.
NMUnivariateLaurentPolynomial(R : NMRing, x : Symbol):
      Exports == Implementation where
  NINT      ==> NMInteger
  NRAT      ==> NMFraction(NMInteger)
  JI64      ==> JLInt64
  INT       ==> Integer
  PI        ==> PositiveInteger
  NNI       ==> NonNegativeInteger
  SUP       ==> SparseUnivariatePolynomial(R)
  parsei    ==> PARSE_-INTEGER$Lisp
  Exports ==> Join(NMCommutativeRing,
      UnivariatePolynomialCategory(R)) with
    --constant? : % -> Boolean
    --++ constant?(p) checks whether or not p is a constant polynomial.
    monomial? : % -> Boolean
    ++ monomial?(p) checks whether or not p is a monomial.
    monomialRecursive? : % -> Boolean
    ++ monomialRecursive?(p) checks whether or not p is
    ++ monomial recurisvely (all scalar types).
    --term? : % -> Boolean
    --++ term?(p) checks whether or not p is a one term polynomial.
    termRecursive? : % -> Boolean
    ++ termRecursive?(p) checks whether or not p as one term,
    ++ recursively (all scalar types).
    -- monic? : % -> Boolean
    -- ++ monic?(p) checks whether or not p  monic.
    -- square? : % -> Boolean
    -- ++ square?(p) checks whether or not p is a perfect square.
    "^" : (%, Integer) -> %
    ++ ^ is the integer exponentiation (possibly negative).
    if R has Algebra(NMFraction(NMInteger)) then
      "+" : (%, Fraction(Integer)) -> %
      ++ p * q is the sum of p and a rational number q (Fraction(Intger))
      "*" : (%, Fraction(Integer)) -> %
      ++ p * q is the product of p with a rational
      ++ number q (Fraction(Integer))
      "+" : (Fraction(Integer), %) -> %
      ++ q * p is the sum of p and a rational number q (Fraction(Intger))
      "*" : (Fraction(Integer), %) -> %
      ++ q * p is the product of p with a rational
      ++ number q (Fraction(Integer))
    "*"   : (%, NNI) -> %
    ++ p * n is the product of p with a non negative integer.
    "*"   : (%, PI) -> %
    ++ p * n is the product of p with a positive integer.
    _quo : (%, %) -> %
    ++ a quo b returns the quotient of \spad{a} and b, forgetting
    ++ the remainder.
    _rem : (%, %) -> %
    ++ a rem b returns the remainder of \spad{a} and b.
    jnulp  : UnivariatePolynomial(x, R) -> %
    ++ jnulp(p) converts the univariate polynomial p to
    ++ a Nemo univariate polynomial.
    factor   : % -> NMFactored(%)
    ++ factor(p) returns the factorization of p using the
    ++ NMFactored domain.
    unit : % -> %
    ++ unit(p) returns unit from the factorization of p.
    --length   : % -> NNI
    --++ length(p) returns the number of coefficients
    --++ in its dense representation. It includes zero coefficients.
    minimumDegree : % -> INT
    ++ minimumDegree(p) returns the minimal exponent of p.
    trailingCoefficient : % -> R
    ++ trailingCoefficient(p) returns the trailing coefficientof p.
    constantCoefficient : % -> R
    ++ constantCoefficient(p) returns the constant of p.
    coefficients : (%, Segment(Integer)) -> JLVector(R)
    ++ coefficients(p, seg) returns the coefficients from the exponent
    ++ range seg.
    truncate : (%, NNI) -> %
    ++ truncate(p, n) return p truncated to n term. It's the remainder
    ++ of the division by x^n.
    mullow : (%, %, NNI) -> %
    ++ mullow(p1,p2,n) is the truncated multiplication of p1 and p2 by n.
    reverse : % -> %
    ++ reverse the coefficients of p (the leading becomes the trailing)
    ++ and normalise the resulting polynomial.
    reverse : (%, NNI) -> %
    ++ reverse the coefficients of p (the leading becomes the trailing)
    ++ and normalise the resulting polynomial. Adjust the length to n so
    ++ the resulting polynomial is trucated or padded with zeroes before
    ++ the leading term if necessary
    coerce   : Variable(x) -> %
    ++ coerce(x) converts the variable x to a Nemo univariate polynomial.
    nemoULPPrint : Boolean -> Boolean
    ++ nemoULPPrint(bool) set the output mode. If set to false, use
    ++ the FriCAS output mode if possible. Otherwise use the Nemo one (default).
  Implementation ==> add
    import from JLUtilityFunctions
    import from JLStringUtilities

    jlInitialize(true)
    Rep := SExpression
    nprint := true

    tmp : SExpression := devaluate(R)$Lisp
    op_of_Ring : Symbol := CAR(tmp)$Lisp

    NRing : String := string(op_of_Ring)
    NULPRing := concat(["ULP",FORMAT(false, "~a", tmp)$Lisp,string(x)])
    NULPRing := jlRegexReplace(NULPRing, jlRegex("[(|)|\s]"), jlSubstitute(""))

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func,a,b) ==> make_jlref_wcall2(func, a, b)$Lisp
    junbfunc(bfunc, a) ==> jl_call1_bool_wrapped_index(bfunc, jlId(a))$Lisp
    jbinbfunc(op,a,b) ==>
      jl_call2_bool_wrapped_index(op, jlId(a), jlId(b))$Lisp

    -- Set up the ring
    tuple : Boolean := jbinbfunc("isa", jobject(jlNMRing()$R)$JLObject,
      jobject("Tuple")$JLObject)
    if tuple then
      jlEvalString(concat([NULPRing,"=laurent_polynomial_ring(",
        jlNMRing()$R, "[1],_"", string(x), "_")"])$String)
    else
      jlEvalString(concat([NULPRing,"=laurent_polynomial_ring(",
        jlNMRing()$R, ",_"", string(x), "_")"])$String)

    strToExpr(s : String) : Union(Expression(Fraction Integer), "failed") ==
      jlRegexMatch?(s, jlRegex("[\[|{|O]")) => "failed"
      str := concat("0$Expression(Fraction Integer)+", s)
      af := parse(str)$InputForm
      av := interpret_in_new_env(af)$InputForm
      retractIfCan(av)$AnyFunctions1(Expression(Fraction Integer))

    nemoULPPrint(b) ==
      oldnprint := nprint
      nprint:=b
      oldnprint

    if R is NMFraction(NMInteger) then
      p : % + q : Fraction(Integer) == jbinfunc("+", p, coerce(q)@NRAT)
      p : % * q : Fraction(Integer) == jbinfunc("*", p, coerce(q)@NRAT)
      q : Fraction(Integer) + p : % == jbinfunc("+", coerce(q)@NRAT, p)
      q : Fraction(Integer) * p : % == jbinfunc("*", coerce(q)@NRAT, p)
      (p  / q) : % == jbinfunc("/" ,p, q)

    jlNMRing() == NULPRing
    jlObject() == jlEvalString(concat(["string(", NULPRing,")"]))@String

    0 == jlref(concat(["zero(", NULPRing, "[1])"]))
    1 == jlref(concat(["one(", NULPRing, "[1])"]))
    monomial?(p) == junbfunc("is_monomial",p)
    monomialRecursive?(p) == junbfunc("is_monomial_recursive",p)
    termRecursive?(p) == junbfunc("is_term_recursive",p)
    unit?(p) == junbfunc("is_unit",p)

    a : R * b : % == jbinfunc("*",a,b)
    a : % * b : R == jbinfunc("*",a,b)
    i : INT  * b : % == jbinfunc("*", coerce(i)@NINT, b)
    a : % * i : INT  == jbinfunc("*", a, coerce(i)@NINT)
    i : NNI  * b : % == jbinfunc("*", coerce(i)@NINT, b)
    a : % * i : NNI  == jbinfunc("*", a, coerce(i)@NINT)
    i : PI  * b : % == jbinfunc("*", coerce(i)@NINT, b)
    a : % * i : PI == jbinfunc("*", a, coerce(i)@NINT)
    a : % ^ i : PI  == jbinfunc("^", a, coerce(i pretend Integer)@NINT)
    a : % ^ i : NNI  == jbinfunc("^", a, coerce(i pretend Integer)@NINT)
    a : % ^ i : Integer  == jbinfunc("^", a, coerce(i)@NINT)
    exactDivide(p,q) == jbinfunc("divexact", p, q)
    (p1:% exquo p2:%) ==
      ret : JLObjTuple := jbinfunc("divides", p1, p2)
      not jlEvalString(concat(["first(", getind(ret), ")"]))@Boolean
        => "failed"
      junfunc("last", ret)@%
    divide(a,b) : Record(quotient : %, remainder : %) ==
      ret : JLObjTuple := jbinfunc("divrem",a,b)
      [ret.1 pretend %, ret.2 pretend %]
    a:% quo b:% == jbinfunc("div", a, b)
    a:% rem b:% == jbinfunc("mod", a, b)
    --pseudoRemainder(p1,p2) == jbinfunc("pseudorem",p1,p2)
    if R has DivisionRing then
      recip(p) ==
        ret : JLObjTuple := jbinfunc("divides", 1$R, p)
        not jlEvalString(concat(["first(", getind(ret), ")"]))@Boolean
          => "failed"
        junfunc("last", ret) pretend %
      p/r : R == inv(r)*p -- TODO
      unitNormal(p) ==
        unitC : R := junfunc("canonical_unit", p)
        a := inv unitC
        [unitC::%, p * a , a::%]
      unitCanonical(p) ==
        a : R := junfunc("canonical_unit", p)
        p * inv a
    else
      recip(p) ==
        unit?(p) => p
        "failed"

    -- Using Nemo factorisation (can be different, over rationals for example)
    -- another method is used for NUP
    -- Here degree is not implemented, so:
    unit(p) == unit factor(p)

    monomial(coef,exp) ==
      jlref(concat([getind(coef),"*", string(x), "^",
        string(exp pretend Integer)]))
    --reductum(p) == junfunc("tail",p)
    gcd(p1,p2)  == jbinfunc("gcd",p1,p2)
    lcm(p1,p2)  == jbinfunc("lcm",p1,p2)
    --content(p : %)  == jlref(concat(["content(", getind(p), ")"]))$R
    --primitivePart(p) == junfunc("primpart", p)
    --discriminant(p) == junfunc("discriminant", p)
    --length(p) == parsei(string(junfunc("length", p)))
    factor(p : %) : NMFactored(%) == factor(p)$NMFactored(%)
    -- error no method degree
    factor(p : %) : Factored(%) == factor(p)$NMFactored(%)

    coefficient(p : %, n : NNI) ==
      jlref(concat ["coeff(", getind(p),",", string(n), ")"])$R
    coefficients(p : %, r : Segment(Integer)) ==
      jlref(concat ["coeff.(", getind(p),",",
        string(low(r)),":", string(high(r)), ")"])$JLVector(R)
    leadingCoefficient(p : %) ==
      junfunc("leading_coefficient", p)
    trailingCoefficient(p) ==
      jlref(concat ["trailing_coefficient(", getind(p),")"])$R
    --constantCoefficient(p) ==
    --  jlref(concat ["constant_coefficient(", getind(p),")"])$R
    --degree(p) == jlEvalString(concat(["degree(", getind(p),")"]))@NNI
    minimumDegree(p) : INT == -- ??
      jlEvalString(concat [getind(p), ".mindeg"])
    --leadingTerm(p) ==
    --  ind := getind(p)
    --  deg : NNI := parsei(string jlref(concat ["degree(", ind,")"])) 
    --  [deg, jlref(concat ["leading_coefficient(", ind,")"])$R]
    --listOfTerms(p) ==
    --  ind := getind(p)
    --  v : JLVector(R) := jlref(concat ["reverse(collect(coefficients(",ind, ")))"]) 
    --  ret : List(Record(k:NNI, c:R)) := []
    --  for i in 0..(#v-1) repeat 
    --    if not zero?(coef := qelt(v,i+1)) then
    --      ret := concat(ret, [(#v-i-1) pretend NNI, coef])
    --  ret
    --truncate(p,n) ==
    --  jlref(concat ["truncate(", getind(p),",", string(n),")"])
    --mullow(p1, p2, n) ==
    --  jlref(concat ["mullow(", getind(p1),",", getind(p2) , ",", string(n),")"])
    --reverse(p) == junfunc("reverse",p)
    --reverse(p,n) == jlref(concat ["reverse(", getind(p),",", string(n),")"])

    -- ... error in Nemo apparently - TODO
    elt(p, at : R) : R == jbinfunc("evaluate", p, at)
    differentiate(p) == junfunc("derivative", p)
    --integrate(p) == junfunc("integral",p)

    jnulp(up) : % ==
      p: String := first(lines formatExpression(up::OutputForm)$Format1D)
      ret := jlRegexReplace(p, jlRegex("/"), jlSubstitute("//"))
      jlref(ret)

    coerce(v : Variable(x)) == jlref(concat(NULPRing,"[2]"))
    coerce(i : Integer) == jlref(concat([NULPRing,"[1](",string(i),")"]))
    coerce(c : R) == jlref(concat [NULPRing,"[1](", getind(c),")"])
    coerce(p : %) : OutputForm ==
      str := jlRegexReplace(string(p), jlString("//"),jlString("/"))
      if nprint then str pretend OutputForm
      else
        (ret := strToExpr(str)) case "failed" => str pretend OutputForm
        coerce(ret)

)abbrev domain INPOLY InnerNMPolynomial
++ Generic sparse multivariate polynomial domain using
++ the Nemo Julia package (using AbstractAlgebra)
++ Author: G. Vanuxem
++ Basic Functions: degree, eval, coefficient, monomial, differentiate,
++ resultant, gcd
++ Date Created: July, 2025
++ Related Constructors: Polynomial, NMUnivariatePolynomial
++ Also See:
++ AMS Classifications:
++ Keywords: polynomial, multivariate, universal polynomial
++ References:
++ Description:
++   This type is a basic representation of generic sparse distributed
++  multivariable polynomial types using the Julia package Nemo
++  (AbstractAlgebra). It is parameterized by the coefficient ring.
-- Experimental domain.
-- TODO: eval, elt, subst, compose, evaluate, constructOrdered ???
InnerNMPolynomial(R : NMRing, Ordering : JLSymbol) : Exports == Implementation where
  NINT      ==> NMInteger
  NRAT      ==> NMFraction(NMInteger)
  JI64      ==> JLInt64
  INT       ==> Integer
  PI        ==> PositiveInteger
  NNI       ==> NonNegativeInteger
  parsei    ==> PARSE_-INTEGER$Lisp
  Exports ==> Join(NMCommutativeRing, PolynomialCategory(R, 
                  IndexedExponents(Symbol), Symbol)) with
    constant? : % -> Boolean
    ++ constant?(p) checks whether or not p is a constant polynomial.
    monomial? : % -> Boolean
    ++ monomial?(p) checks whether or not p is a monomial.
    monomialRecursive? : % -> Boolean
    ++ monomialRecursive?(p) checks whether or not p is
    ++ monomial recurisvely (all scalar types).
    term? : % -> Boolean
    ++ term?(p) checks whether or not p is a one term polynomial.
    termRecursive? : % -> Boolean
    ++ termRecursive?(p) checks whether or not p as one term polynomial
    ++ recursively on all scalar types.
    univariate? : % -> Boolean
    ++ univariate?(p) checks whether or not p is a univariate polynomial.
    square? : % -> Boolean
    ++ square?(p) checks whether or not p is a perfect square.
    if R has Algebra(NMFraction(NMInteger)) then
      "+" : (%, Fraction(Integer)) -> %
      ++ p + q is the sum of a p with a rational
      ++ number q (Fraction(Integer))
      "*" : (%, Fraction(Integer)) -> %
      ++ p * q is the product of p with a rational
      ++ number q (Fraction(Integer)) 
      "+" : (Fraction(Integer), %) -> %
      ++ q + p is the sum of a p with a rational
      ++ number q (Fraction(Integer))
      "*" : (Fraction(Integer), %) -> %
      ++ q * p is the product of p with a rational
      ++ q (Fraction(Intger)) 
    "*"      : (%, PositiveInteger) -> %
    ++ * is the positive integer multiplication.
    "*"      : (%, NonNegativeInteger) -> %
    ++ * is the non negative integer multiplication.
    exactDivide : (%, %) -> %
    ++ exactDivide(p,q) divides p by q if the division is exact.
    --jmp2nmp : MultivariatePolynomial(VarSet,R) -> %
    --++ jmp2nmp(p) converts the multivariate polynomial p to
    --++ a Nemo multivariate polynomial.
    factor   : % -> NMFactored(%)
    ++ factor(p) returns the factorization of p.
    degree   : (%, PI) -> NNI
    ++ degree(p,i) returns the degree of the i-th variable.
    length   : % -> NNI
    ++ length(p) retruns the number of terms of p.
    coefficients : % -> JLVector(R)
    ++ coefficients(p) returns a Julia vector of coefficients of p.
    monomials : % -> JLVector(%)
    ++ monomials(p) returns the list of non-zero monomials of p
    ++ includind its coefficients.
    primitiveMonomials : % -> JLVector(%)
    ++ primitiveMonomials(p) returns the list of non-zero
    ++ primitive monomials of p i.e. not including its coefficients.
    trailingCoefficient : % -> R
    ++ trailingCoefficient(p) returns the trailing coefficientof p.
    constantCoefficient : % -> R
    ++ constantCoefficient(p) returns the constant of p.
    internalOrdering : () -> JLObject
    ++ internalOrdering() returns the internal ordering used by Nemo.
    ++ It is determined at instantiation time.
    vectorOfTerms : % -> JLVector(%)
    ++ vectorOfTerms(p) returns the Julia vector whose elements are terms of p.
    nemoPPrint : Boolean -> Boolean
    ++ nemoPPrint(bool) set the output mode. If set to false (default), use
    ++ the FriCAS output mode if possible. Otherwise use the Nemo one.
  Implementation ==> add
    import from JLUtilityFunctions
    import from JLStringUtilities
    import from JLSymbol

    jlInitialize(true)
    Rep := SExpression
    nprint := false

    tmp : SExpression := devaluate(R)$Lisp
    op_of_Ring : Symbol := CAR(tmp)$Lisp

    -- FriCAS NMRing of R
    NRing : String := string(op_of_Ring)
    -- Our Nemo Ring
    NUNPRing := jlRegexReplace(concat("NUPOLY", FORMAT(false, "~a", tmp)$Lisp),
      jlRegex("[(|)|\s]"), jlSubstitute(""))
 
    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func,a,b) ==> make_jlref_wcall2(func, a, b)$Lisp
    junbfunc(bfunc, a) ==> jl_call1_bool_wrapped_index(bfunc, jlId(a))$Lisp
    jbinbfunc(op,a,b) ==>
      jl_call2_bool_wrapped_index(op, jlId(a), jlId(b))$Lisp

    -- Set up the ring
    tuple : Boolean := jbinbfunc("isa", jobject(jlNMRing()$R)$JLObject,
      jobject("Tuple")$JLObject)
    if tuple then
      jlEvalString(concat([NUNPRing, "=universal_polynomial_ring(",
        jlNMRing()$R,"[1];internal_ordering=",
          string(Ordering),")"]))
    else
      jlEvalString(concat([NUNPRing, "=universal_polynomial_ring(",
        jlNMRing()$R,";internal_ordering=",
          string(Ordering),")"]))

    strToPoly(s : String) : Union(Polynomial(Fraction Integer), "failed") ==
      jlRegexMatch?(s, jlRegex("[\[|{|O]")) => "failed"
      str := concat("0$Polynomial(Fraction Integer)+", s)
      af := parse(str)$InputForm
      av := interpret_in_new_env(af)$InputForm
      retractIfCan(av)$AnyFunctions1(Polynomial(Fraction Integer))

    if R is NMFraction(NMInteger) then
      p : % + q : Fraction(Integer) == jbinfunc("+", p, coerce(q)@NRAT)
      p : % * q : Fraction(Integer) == jbinfunc("*", p, coerce(q)@NRAT)
      q : Fraction(Integer) + p : % == jbinfunc("+", coerce(q)@NRAT, p)
      q : Fraction(Integer) * p : % == jbinfunc("*", coerce(q)@NRAT, p)
      (p / q) : % == jbinfunc("/", p, q)

    jlNMRing() == NUNPRing
    jlObject() == jlEvalString(concat(["string(", NUNPRing,")"]))@String
    internalOrdering() ==
      jlref(concat(["internal_ordering(",NUNPRing,")"]))$JLObject
    nemoPPrint(b) ==
      oldnprint := nprint
      nprint:=b
      oldnprint

    0 == jlref(concat(["zero(",NUNPRing,")"]))
    1 == jlref(concat(["one(",NUNPRing,")"]))
    one?(p) == junbfunc("isone",p)
    zero?(p) == junbfunc("iszero",p)
    constant?(p) == junbfunc("is_constant",p)
    monomial?(p) == junbfunc("is_monomial",p)
    monomialRecursive?(p) == junbfunc("is_monomial_recursive",p)
    term?(p) == junbfunc("is_term",p)
    termRecursive?(p) == junbfunc("is_term_recursive",p)
    unit?(p) == junbfunc("is_unit",p)
    univariate?(p) == junbfunc("is_univariate",p)
    square?(p) == junbfunc("is_square",p)

    a : R * b : % == jbinfunc("*",a,b)
    a : % * b : R == jbinfunc("*",a,b)
    i : INT  * b : % == jbinfunc("*", coerce(i)@NINT, b)
    a : % * i : INT  == jbinfunc("*", a, coerce(i)@NINT)
    a : % * i : PI  == jbinfunc("*", a, coerce(i pretend Integer)@NINT)
    a : % * i : NNI  == jbinfunc("*", a, coerce(i pretend Integer)@NINT)
    a : % ^ i : PI  == jbinfunc("^", a, coerce(i pretend Integer)@NINT)
    a : % ^ i : NNI  == jbinfunc("^", a, coerce(i pretend Integer)@NINT)
    exactDivide(p,q) == jbinfunc("divexact", p, q)

    monomial(c : R, k : IndexedExponents(Symbol)) : % ==
      res : % := c::%
      while k ~= 0 repeat
        v := leadingSupport(k)
        e := leadingCoefficient(k)
        res := res * (v::%)^e
        k := reductum(k)
      res

    constructOrdered(terms : List Record(k: IndexedExponents(Symbol), c: R)) : % ==
      res : % := 0
      for t in terms repeat
        res := res + monomial(t.c, t.k)
      res

    construct(terms) == constructOrdered(terms)

    (p1:% exquo p2:%) ==
      ret : JLObjTuple := jbinfunc("divides", p1, p2)
      not jlEvalString(concat(["first(", getind(ret), ")"]))@Boolean
        => "failed"
      junfunc("last", ret)@%
    characteristic() ==
      jlEvalString(concat(["characteristic(", NUNPRing,"[1])"]))
    reductum(p) == junfunc("tail",p)
    gcd(p1,p2)  == jbinfunc("gcd",p1,p2)
    lcm(p1,p2)  == jbinfunc("lcm",p1,p2)
    factor(a : %) : NMFactored(%) == factor(a)$NMFactored(%)
    factor(a : %) : Factored(%) == factor(a)$NMFactored(%)
    --mainVariable(p : %) ==
    --  jlEvalString(concat(["is_constant(", getind(p),")"]))@Boolean
    --    => "failed"
    --  sym : String := jlEvalString(concat ["string(vars(",getind(p),")[1])"])  
    --  variable(sym::Symbol)$OrderedVariableList(VarSet)
    variables(p) ==
      l : List(Symbol) := []
      v : JLVector(%) := junfunc("vars",p)
      for i in 1..#v repeat
        l := concat!(l,string(v.i)::Symbol)
      l
    length(p) == jlEvalString(concat(["length(", getind(p),")"]))

    coefficients(p) : JLVector(R) ==
      jlref(concat ["collect(coefficients(", getind(p),"))"])
    coefficients(p) : List(R) ==
      members(jlref(concat ["collect(coefficients(",
        getind(p),"))"])$JLVector(R))

    leadingMonomial(p) == junfunc("leading_term", p)
    leadingCoefficient(p : %) ==
      junfunc("leading_coefficient", p)
    trailingCoefficient(p) ==
      jlref(concat ["trailing_coefficient(", getind(p),")"])$R
    constantCoefficient(p) ==
      jlref(concat ["constant_coefficient(", getind(p),")"])$R
    monomials(p) : List(%) ==
      vmon := jlref(concat ["collect(terms(", getind(p),"))"])$JLVector(%)
      l : List(%) := [] 
      for i in 1..#vmon repeat
        l := concat(l, vmon.i)
      l
    monomials(p) : JLVector(%) ==
      jlref(concat ["collect(terms(", getind(p),"))"])$JLVector(%)
    primitiveMonomials(p) : List(%) ==
      terms := jlref(concat ["collect(monomials(", getind(p),"))"])$JLVector(%)
      l : List(%) := [] 
      for i in 1..#terms repeat
        l := concat(l, terms.i)
      l
    -- TODO to FriCAS array returns
    primitiveMonomials(p) : JLVector(%) ==
      jlref(concat ["collect(monomials(", getind(p),"))"])$JLVector(%)

    --leadingTerm(p) == 
    --  tp : JLObject := junfunc("leading_term", p)
    --  ind := getind(tp)
    --  coef := jlref(concat ["coeff(", ind,",1)"])$R
    --  vs := jlref(concat(["vars(", ind, ")"]))$JLVector(%)
    --  res : List(Record(k:OrderedVariableList(VarSet),c:NNI)):=[]
    --  for i in 1..#vs repeat
    --    sym : String := jlEvalString(concat ["string(", getind(qelt(vs,i)),")"])
    --    exp := jlEvalString(concat(["degree(", ind,",", sym, ")"]))@NNI
    --    res:=concat(res,
    --      [coerce(variable(coerce(sym)$Symbol)$OrderedVariableList(VarSet))@OrderedVariableList(VarSet),
    --        exp]$Record(k:OrderedVariableList(VarSet),c:NNI))
    --  [construct(res)$IndexedExponents(OrderedVariableList(VarSet)), coef]

    -- TODO: Iterators
    vectorOfTerms(p) == 
      jlref(concat ["collect(terms(", getind(p),"))"])

    -- TODO: extremely expensive
    listOfTerms(p) == 
      v : JLVector(%) := jlref(concat ["collect(terms(", getind(p),"))"])
      ret : List(Record(k: IndexedExponents(Symbol), c: R)) := []
      for i in 1..#v repeat
        ind := getind(v.i)
        coef := jlref(concat ["coeff(", ind,",1)"])$R
        vs := jlref(concat(["vars(", ind, ")"]))$JLVector(%)
        res : List(Record(k:Symbol, c:NNI)):=[]
        for j in 1..#vs repeat
          elt := getind(qelt(vs,j))
          sym : String := jlEvalString(concat ["string(", elt,")"])
          exp := jlEvalString(concat(["degree(", ind, ",", elt, ")"]))@NNI
          res:= concat(res,[coerce(sym)@Symbol, exp])
        ret := concat(ret,[construct(res)$IndexedExponents(Symbol), coef])
      ret

    --minimumDegree(p) ==
    --  lterm := jlref(concat ["last(collect(terms(", getind(p),")))"])
    --  ind := getind(lterm)
    --  sym := jlEvalString(concat(["string(last(vars(", ind, ")))"]))@String
    --  exp := jlEvalString(concat(["degree(", ind,",", sym, ")"]))@NNI
    --  monomial(exp,
    --    coerce(variable(coerce(sym)$Symbol)$OrderedVariableList(VarSet)))
    --      $IndexedExponents(OrderedVariableList(VarSet))

    --degree(p : %) ==
    --  ind := getind(p)
    --  tp : JLObject := jlref(concat(["leading_monomial(", ind, ")"]))
    --  ind := getind(tp)
    --  vs := jlref(concat(["vars(", ind, ")"]))$JLVector(%)
    --  res : List(Record(k:OrderedVariableList(VarSet),c:NNI)):=[]
    --  for i in 1..#vs repeat
    --    sym : String := jlEvalString(concat ["string(", getind(qelt(vs,i)),")"])
    --    exp := jlEvalString(concat(["degree(", ind,",", sym, ")"]))@NNI
    --    res:=concat(res,
    --      [coerce(variable(coerce(sym)$Symbol)$OrderedVariableList(VarSet))@OrderedVariableList(VarSet),
    --        exp]$Record(k:OrderedVariableList(VarSet),c:NNI))
    --  construct(res)$IndexedExponents(OrderedVariableList(VarSet))

    --degree(p : %, var : OrderedVariableList(VarSet)) ==
    --  ind := lookup(var)
    --  jlEvalString(concat(["degree(", getind(p),",", string(ind),")"]))@NNI

    degree(p : %, index : PI) ==
      jlEvalString(concat(["degree(", getind(p),",", string(index),")"]))@NNI

    -- unitCanonical(p) == junfunc("canonical_unit", p) -- The Nemo one 
    recip(p) ==
      unit?(p) => p
      "failed"

    if R has DivisionRing then
      p/r : R == inv(r)*p
      unitNormal(p) ==
        unitC : R := junfunc("canonical_unit", p)
        a := inv unitC
        [unitC::%, p * a , a::%]
      unitCanonical(p) ==
        a : R := junfunc("canonical_unit", p)
        p * inv a

    --jmp2nmp(mp) : % ==
    --  p: String := first(lines formatExpression(mp::OutputForm)$Format1D)
    --  ret := jlRegexReplace(p,jlRegex("/"), jlSubstitute("//"))
    --  jlref(ret)

    retractIfCan(p : %) : Union(R,"failed") ==
      jlEvalString(concat(["is_constant(", getind(p),")"]))@Boolean
        => jlref(string(p))$R -- Huh: TODO
      "failed"

    coerce(v : Symbol) ==
      jlref(concat(["gen(", NUNPRing,",", string(jsym v),")"]))
    coerce(i : Integer) == jlref(concat([NUNPRing, "(", string(i), ")"]))
    coerce(c : R) == jlref(concat([NUNPRing, "(", getind(c),")"]))
    coerce(p : %) : OutputForm ==
      -- reverse order (TODO)
      str := jlRegexReplace(string(p), jlString("//"),jlString("/"))
      if nprint then str pretend OutputForm
      else
        (ret := strToPoly(str)) case "failed" => str pretend OutputForm
        coerce(ret)

)abbrev domain NPOLY NMPolynomial
++ Generic sparse multivariate polynomial domain using
++ the Julia package Nemo (using AbstractAlgebra)
++ Author: G. Vanuxem
++ Basic Functions: degree, eval, coefficient, monomial, differentiate,
++ resultant, gcd
++ Date Created: March, 2025
++ Related Constructors: Polynomial, NMUnivariatePolynomial
++ Also See:
++ AMS Classifications:
++ Keywords: polynomial, multivariate
++ References:
++ Description:
++   This type is a basic representation of generic sparse distributed
++  multivariable polynomial types using the Julia package Nemo
++  (AbstractAlgebra). It is parameterized by the coefficient ring.
++ Experimental domain.
-- TODO: eval, elt, subst, compose, evaluate, constructOrdered ???
NMPolynomial(R : NMRing) == InnerNMPolynomial(R, coerce("lex")@JLSymbol)

)abbrev domain INMP InnerNMMultivariatePolynomial
++ Multivariate polynomial domain using the Julia package Nemo
++ Author: G. Vanuxem
++ Basic Functions: degree, eval, coefficient, monomial, differentiate,
++ resultant, gcd
++ Date Created: March, 2024
++ Related Constructors: Polynomial, NMUnivariatePolynomial
++ Also See:
++ AMS Classifications:
++ Keywords: polynomial, multivariate
++ References:
++ Description:
++   This type is a basic representation of sparse, distributed multivariate
++ polynomials using the Julia package Nemo. It is parameterized by the
++ coefficient ring. The coefficient ring may be non-commutative,
++ but the variables are assumed to commute. The monomial ordering
++ used for internal storage can be one of :lex, :deglex or :degrevlex.
++  For example:
++   VarSet: List Symbol:=[x,y,z]
++   V := OrderedVariableList(VarSet)
++   -- eventually, for later use
++   -- See SparseMultivariatePolynomial
++   -- E := IndexedExponents V
++   PRing := NMP(NINT,VarSet, "lex")
++   x := x::V::PRing
++   y := y::V::PRing
++   z := z:f:V::PRing
++   p:=x*2+3*y^2+17*z^13
++   p^7
-- https://en.wikipedia.org/wiki/Monomial_order
-- TODO: eval, elt, subst, compose, evaluate, constructOrdered
InnerNMMultivariatePolynomial(R : NMRing, VarSet : List Symbol,
          Ordering : JLSymbol) : Exports == Implementation where
  NINT      ==> NMInteger
  NRAT      ==> NMFraction(NMInteger)
  JI64      ==> JLInt64
  INT       ==> Integer
  PI        ==> PositiveInteger
  NNI       ==> NonNegativeInteger
  parsei    ==> PARSE_-INTEGER$Lisp
  Exports ==> Join(NMCommutativeRing, PolynomialCategory(R, 
                  IndexedExponents(OrderedVariableList(VarSet)),
                    OrderedVariableList(VarSet))) with
    constant? : % -> Boolean
    ++ constant?(p) checks whether or not p is a constant polynomial.
    monomial? : % -> Boolean
    ++ monomial?(p) checks whether or not p is a monomial.
    monomialRecursive? : % -> Boolean
    ++ monomialRecursive?(p) checks whether or not p is
    ++ monomial recurisvely (all scalar types).
    term? : % -> Boolean
    ++ term?(p) checks whether or not p is a one term polynomial.
    termRecursive? : % -> Boolean
    ++ termRecursive?(p) checks whether or not p as one term polynomial
    ++ recursively on all scalar types.
    univariate? : % -> Boolean
    ++ univariate?(p) checks whether or not p is a univariate polynomial.
    square? : % -> Boolean
    ++ square?(p) checks whether or not p is a perfect square.
    if R has Algebra(NMFraction(NMInteger)) then
      "+" : (%, Fraction(Integer)) -> %
      ++ p + q is the sum of a p with a rational
      ++ number q (Fraction(Integer))
      "*" : (%, Fraction(Integer)) -> %
      ++ p * q is the product of p with a rational
      ++ number q (Fraction(Integer)) 
      "+" : (Fraction(Integer), %) -> %
      ++ q + p is the sum of a p with a rational
      ++ number q (Fraction(Integer))
      "*" : (Fraction(Integer), %) -> %
      ++ q * p is the product of p with a rational
      ++ q (Fraction(Intger)) 
    "*"      : (%, PositiveInteger) -> %
    ++ * is the positive integer multiplication.
    "*"      : (%, NonNegativeInteger) -> %
    ++ * is the non negative integer multiplication.
    exactDivide : (%, %) -> %
    ++ exactDivide(p,q) divides p by q if the division is exact.
    shiftLeft : (%, NNI) -> %
    ++ shiftLeft(p) left shift p.
    shiftRight : (%, NNI) -> %
    ++ shiftRight(p) right shift p.
    shiftLeft! : (%, NNI) -> %
    ++ shiftLeft(p) left shift p.
    shiftRight! : (%, NNI) -> %
    ++ shiftRight(p) right shift p.
    jmp2nmp : MultivariatePolynomial(VarSet,R) -> %
    ++ jmp2nmp(p) converts the multivariate polynomial p to
    ++ a Nemo multivariate polynomial.
    factor   : % -> NMFactored(%)
    ++ factor(p) returns the factorization of p.
    degree   : (%, PI) -> NNI
    ++ degree(p,i) returns the degree of the i-th variable.
    length   : % -> NNI
    ++ length(p) retruns the number of terms of p.
    coefficients : % -> JLVector(R)
    ++ coefficients(p) returns a Julia vector of coefficients of p.
    monomials : % -> JLVector(%)
    ++ monomials(p) returns the list of non-zero monomials of p
    ++ includind its coefficients.
    primitiveMonomials : % -> JLVector(%)
    ++ primitiveMonomials(p) returns the list of non-zero
    ++ primitive monomials of p i.e. not including its coefficients.
    trailingCoefficient : % -> R
    ++ trailingCoefficient(p) returns the trailing coefficientof p.
    constantCoefficient : % -> R
    ++ constantCoefficient(p) returns the constant of p.
    internalOrdering : () -> JLObject
    ++ internalOrdering() returns the internal ordering used by Nemo.
    ++ It is determined at instantiation time.
    vectorOfTerms : % -> JLVector(%)
    ++ vectorOfTerms(p) returns the Julia vector whose elements are terms of p.
    exponent_vectors : % -> JLVector(JLVector(JLObjInt64))
    ++ exponent_vectors(lp) returns the exponent vectors.
    leading_monomial : % -> %
    ++ leading_monomial(lp) returns the leading monomial.
    leading_exponent_vector : % -> JLVector(JLObjInt64)
    ++ leading_exponent_vector(lp) returns the of leading exponent.
    nemoMPPrint : Boolean -> Boolean
    ++ nemoMPPrint(bool) set the output mode. If set to false (default), use
    ++ the FriCAS output mode if possible. Otherwise use the Nemo one.
  Implementation ==> add
    import from JLUtilityFunctions
    import from JLStringUtilities

    jlInitialize(true)
    Rep := SExpression
    nprint := false

    tmp : SExpression := devaluate(R)$Lisp
    op_of_Ring : Symbol := CAR(tmp)$Lisp

    -- FriCAS NMRing of R
    NRing : String := string(op_of_Ring)
    -- Our Nemo Ring
    NMPRing := jlRegexReplace(concat("MP", FORMAT(false, "~a", tmp)$Lisp),
      jlRegex("[(|)|\s]"), jlSubstitute(""))

    -- Check VarSet (TODO: reflect SMP)
    #VarSet ~= #removeDuplicates(VarSet) =>
      error "Duplicate symbols in NMMultivariatePolynomial constructor" 

    -- List of double-quoted vars     
    lvars := map(v +-> string(v), VarSet)$ListFunctions2(Symbol, String)
    -- vars for polynomial_ring() arguments
    jvars := first lines formatExpression(lvars::OutputForm)$Format1D
    
    -- Our Julia ring
    
    NMPRing := concat([NMPRing, concat(lvars)])

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func,a,b) ==> make_jlref_wcall2(func, a, b)$Lisp
    junbfunc(bfunc, a) ==> jl_call1_bool_wrapped_index(bfunc, jlId(a))$Lisp
    jbinbfunc(op,a,b) ==>
      jl_call2_bool_wrapped_index(op, jlId(a), jlId(b))$Lisp

    -- Set up the ring
    tuple : Boolean := jbinbfunc("isa", jobject(jlNMRing()$R)$JLObject,
      jobject("Tuple")$JLObject)
    if tuple then
      jlEvalString(concat([NMPRing, "=polynomial_ring(",
        jlNMRing()$R,"[1],", jvars,";internal_ordering=",
          string(Ordering),")"])$String)
    else
      jlEvalString(concat([NMPRing, "=polynomial_ring(",
        jlNMRing()$R,",", jvars,";internal_ordering=",
          string(Ordering),")"])$String)

    strToPoly(s : String) : Union(Polynomial(Fraction Integer), "failed") ==
      jlRegexMatch?(s, jlRegex("[\[|{|O]")) => "failed"
      str := concat("0$Polynomial(Fraction Integer)+", s)
      af := parse(str)$InputForm
      av := interpret_in_new_env(af)$InputForm
      retractIfCan(av)$AnyFunctions1(Polynomial(Fraction Integer))

    if R is NMFraction(NMInteger) then
      p : % + q : Fraction(Integer) == jbinfunc("+", p, coerce(q)@NRAT)
      p : % * q : Fraction(Integer) == jbinfunc("*", p, coerce(q)@NRAT)
      q : Fraction(Integer) + p : % == jbinfunc("+", coerce(q)@NRAT, p)
      q : Fraction(Integer) * p : % == jbinfunc("*", coerce(q)@NRAT, p)
      (p / q) : % == jbinfunc("/", p, q)

    jlNMRing() == NMPRing
    jlObject() == jlEvalString(concat(["string(", NMPRing,")"]))@String
    internalOrdering() ==
      jlref(concat(["internal_ordering(",NMPRing,"[1])"]))$JLObject
    nemoMPPrint(b) ==
      oldnprint := nprint
      nprint:=b
      oldnprint

    0 == jlref(concat(["zero(",NMPRing,"[1])"]))
    1 == jlref(concat(["one(",NMPRing,"[1])"]))
    one?(p) == junbfunc("isone",p)
    zero?(p) == junbfunc("iszero",p)
    constant?(p) == junbfunc("is_constant",p)
    monomial?(p) == junbfunc("is_monomial",p)
    monomialRecursive?(p) == junbfunc("is_monomial_recursive",p)
    term?(p) == junbfunc("is_term",p)
    termRecursive?(p) == junbfunc("is_term_recursive",p)
    unit?(p) == junbfunc("is_unit",p)
    univariate?(p) == junbfunc("is_univariate",p)
    square?(p) == junbfunc("is_square",p)

    a : R * b : % == jbinfunc("*",a,b)
    a : % * b : R == jbinfunc("*",a,b)
    i : INT  * b : % == jbinfunc("*", coerce(i)@NINT, b)
    a : % * i : INT  == jbinfunc("*", a, coerce(i)@NINT)
    a : % * i : PI  == jbinfunc("*", a, coerce(i pretend Integer)@NINT)
    a : % * i : NNI  == jbinfunc("*", a, coerce(i pretend Integer)@NINT)
    a : % ^ i : PI  == jbinfunc("^", a, coerce(i pretend Integer)@NINT)
    a : % ^ i : NNI  == jbinfunc("^", a, coerce(i pretend Integer)@NINT)
    exactDivide(p,q) == jbinfunc("divexact", p, q)

    monomial(c : R, k : IndexedExponents(OrderedVariableList(VarSet))) : % ==
      res : % := c::%
      while k ~= 0 repeat
        v := leadingSupport(k)
        e := leadingCoefficient(k)
        res := res * (v::%)^e
        k := reductum(k)
      res

    constructOrdered(terms : List Record(k: IndexedExponents(OrderedVariableList(VarSet)), c: R)) : % ==
      res : % := 0
      for t in terms repeat
        res := res + monomial(t.c, t.k)
      res

    construct(terms) == constructOrdered(terms)

    (p1:% exquo p2:%) ==
      ret : JLObjTuple := jbinfunc("divides", p1, p2)
      not jlEvalString(concat(["first(", getind(ret), ")"]))@Boolean
        => "failed"
      junfunc("last", ret)@%
    characteristic() ==
      jlEvalString(concat(["characteristic(", NMPRing,"[1])"]))
    reductum(p) == junfunc("tail",p)
    gcd(p1,p2)  == jbinfunc("gcd",p1,p2)
    lcm(p1,p2)  == jbinfunc("lcm",p1,p2)
    factor(a : %) : NMFactored(%) == factor(a)$NMFactored(%)
    factor(a : %) : Factored(%) == factor(a)$NMFactored(%)
    mainVariable(p : %) ==
      jlEvalString(concat(["is_constant(", getind(p),")"]))@Boolean
        => "failed"
      sym : String := jlEvalString(concat ["string(vars(",getind(p),")[1])"])  
      variable(sym::Symbol)$OrderedVariableList(VarSet)
    variables(p) == enumerate()$OrderedVariableList(VarSet)
    length(p) == jlEvalString(concat(["length(", getind(p),")"]))
    shiftLeft(p,n) == jlref(concat ["shift_left(", getind(p),",", string(n),")"])
    shiftRight(p,n) == jlref(concat ["shift_right(", getind(p),",", string(n),")"])
    shiftLeft!(p,n) == jlref(concat ["shift_left!(", getind(p),",", string(n),")"])
    shiftRight!(p,n) == jlref(concat ["shift_right!(", getind(p),",", string(n),")"])

    coefficients(p) : JLVector(R) ==
      jlref(concat ["collect(coefficients(", getind(p),"))"])
    coefficients(p) : List(R) ==
      members(jlref(concat ["collect(coefficients(",
        getind(p),"))"])$JLVector(R))

    leadingMonomial(p) == junfunc("leading_term", p)
    leadingCoefficient(p : %) ==
      junfunc("leading_coefficient", p)
    trailingCoefficient(p) ==
      jlref(concat ["trailing_coefficient(", getind(p),")"])$R
    constantCoefficient(p) ==
      jlref(concat ["constant_coefficient(", getind(p),")"])$R
    monomials(p) : List(%) ==
      vmon := jlref(concat ["collect(terms(", getind(p),"))"])$JLVector(%)
      l : List(%) := [] 
      for i in 1..#vmon repeat
        l := concat(l, vmon.i)
      l
    monomials(p) : JLVector(%) ==
      jlref(concat ["collect(terms(", getind(p),"))"])$JLVector(%)
    primitiveMonomials(p) : List(%) ==
      terms := jlref(concat ["collect(monomials(", getind(p),"))"])$JLVector(%)
      l : List(%) := [] 
      for i in 1..#terms repeat
        l := concat(l, terms.i)
      l
    -- TODO to FriCAS array returns
    primitiveMonomials(p) : JLVector(%) ==
      jlref(concat ["collect(monomials(", getind(p),"))"])$JLVector(%)
  
    leadingTerm(p) == 
      tp : JLObject := junfunc("leading_term", p)
      ind := getind(tp)
      coef := jlref(concat ["coeff(", ind,",1)"])$R
      vs := jlref(concat(["vars(", ind, ")"]))$JLVector(%)
      res : List(Record(k:OrderedVariableList(VarSet),c:NNI)):=[]
      for i in 1..#vs repeat
        elt := getind(qelt(vs,i))
        sym : String := jlEvalString(concat ["string(", elt,")"])
        exp := jlEvalString(concat(["degree(", ind,",", elt, ")"]))@NNI
        res:=concat(res,
          [coerce(variable(coerce(sym)$Symbol)$OrderedVariableList(VarSet))@OrderedVariableList(VarSet),
            exp]$Record(k:OrderedVariableList(VarSet),c:NNI))
      [construct(res)$IndexedExponents(OrderedVariableList(VarSet)), coef]

    -- TODO: Iterators
    vectorOfTerms(p) == 
      jlref(concat ["collect(terms(", getind(p),"))"])

    listOfTerms(p) == 
      v : JLVector(%) := jlref(concat ["collect(terms(", getind(p),"))"])
      ret : List(Record(k: IndexedExponents(OrderedVariableList(VarSet)),c: R)) := []
      for i in 1..#v repeat
        ind := getind(v.i)
        coef := jlref(concat ["coeff(", ind,",1)"])$R
        vs := jlref(concat(["vars(", ind, ")"]))$JLVector(%)
        res : List(Record(k:OrderedVariableList(VarSet),c:NNI)):=[]
        for j in 1..#vs repeat
          elt := getind(qelt(vs,j))
          sym : String := jlEvalString(concat ["string(", elt,")"])
          exp := jlEvalString(concat(["degree(", ind, ",", elt, ")"]))@NNI
          res:= concat(res,
            [coerce(variable(coerce(sym)$Symbol)$OrderedVariableList(VarSet))@OrderedVariableList(VarSet),
              exp]$Record(k:OrderedVariableList(VarSet),c:NNI))
        ret := concat(ret,[construct(res)$IndexedExponents(OrderedVariableList(VarSet)), coef])
      ret

    minimumDegree(p) ==
      constant?(p) => 0
      lterm: % := jlref(concat ["last(collect(terms(", getind(p),")))"])
      constant?(lterm) => 0
      ind := getind(lterm)
      var :=  jlref(concat ["last(vars(", ind, "))"])
      exp := jlEvalString(concat(["degree(", ind, ",", getind(var),")"]))@NNI
      monomial(exp,
        coerce(variable(coerce(string var)$Symbol)$OrderedVariableList(VarSet)))
          $IndexedExponents(OrderedVariableList(VarSet))

    degree(p : %) ==
      tp : JLObject := jlref(concat(["leading_monomial(", getind(p), ")"]))
      ind := getind(tp)
      vs := jlref(concat(["vars(", ind, ")"]))$JLVector(%)
      res : List(Record(k:OrderedVariableList(VarSet),c:NNI)):=[]
      for i in 1..#vs repeat
        elt := getind(qelt(vs,i))
        sym : String := jlEvalString(concat ["string(", elt,")"])
        exp := jlEvalString(concat(["degree(", ind,",", elt, ")"]))@NNI
        res:=concat(res,
          [coerce(variable(coerce(sym)$Symbol)$OrderedVariableList(VarSet))@OrderedVariableList(VarSet),
            exp]$Record(k:OrderedVariableList(VarSet),c:NNI))
      construct(res)$IndexedExponents(OrderedVariableList(VarSet))

    degree(p : %, var : OrderedVariableList(VarSet)) ==
      ind := lookup(var)
      jlEvalString(concat(["degree(", getind(p),",", string(ind),")"]))@NNI
    degree(p : %, index : PI) ==
      jlEvalString(concat(["degree(", getind(p),",", string(index),")"]))@NNI

    exponent_vectors(p) ==
      jlref(concat ["collect(exponent_vectors(", getind(p),"))"])
    leading_monomial(p) == junfunc("leading_monomial", p)
    leading_exponent_vector(p) == junfunc("leading_exponent_vector", p)

    -- unitCanonical(p) == junfunc("canonical_unit", p) -- The Nemo one 
    recip(p) ==
      unit?(p) => p
      "failed"
    if R has DivisionRing then
      p/r : R == inv(r)*p
      unitNormal(p) ==
        unitC : R := junfunc("canonical_unit", p)
        a := inv unitC
        [unitC::%, p * a , a::%]
      unitCanonical(p) ==
        a : R := junfunc("canonical_unit", p)
        p * inv a

    jmp2nmp(mp) : % ==
      p: String := first(lines formatExpression(mp::OutputForm)$Format1D)
      ret := jlRegexReplace(p,jlRegex("/"), jlSubstitute("//"))
      jlref(ret)

    retractIfCan(p : %) : Union(R,"failed") ==
      jlEvalString(concat(["is_constant(", getind(p),")"]))@Boolean
        => jlref(string(p))$R -- Huh: TODO
      "failed"

    coerce(v : OrderedVariableList(VarSet)) ==
      i := lookup(v)$OrderedVariableList(VarSet)
      jlref(concat([NMPRing,"[2][", string(i),"]"]))
    coerce(i : Integer) == jlref(concat([NMPRing, "[1](", string(i), ")"]))
    coerce(c : R) == jlref(concat([NMPRing, "[1](", getind(c),")"]))
    coerce(p : %) : OutputForm ==
      -- reverse order (TODO)
      str := jlRegexReplace(string(p), jlString("//"),jlString("/"))
      if nprint then str pretend OutputForm
      else
        (ret := strToPoly(str)) case "failed" => str pretend OutputForm
        coerce(ret)

)abbrev domain NMP NMMultivariatePolynomial
++ Multivariate polynomial domain using the Julia package Nemo
++ Author: G. Vanuxem
++ Basic Functions: degree, eval, coefficient, monomial, differentiate,
++ resultant, gcd
++ Date Created: March, 2025
++ Related Constructors: Polynomial, InnerNMultivariatePolynomial
++ Also See:
++ AMS Classifications:
++ Keywords: polynomial, multivariate
++ References:
++ Description:
++   This type is a basic representation of sparse, distributed multivariate
++ polynomials using the Julia package Nemo. It is parameterized by the
++ coefficient ring. The coefficient ring may be non-commutative,
++ but the variables are assumed to commute. The monomial ordering
++ used for internal storage is lexicographic.
++  For example:
++   VarSet: List Symbol:=[x,y,z]
++   V := OrderedVariableList(VarSet)
++   -- eventually, for later use
++   -- See SparseMultivariatePolynomial
++   -- E := IndexedExponents V
++   PRing := NMP(NINT,VarSet)
++   x := x::V::PRing
++   y := y::V::PRing
++   z := z:f:V::PRing
++   p:=x*2+3*y^2+17*z^13
++   p^7
-- https://en.wikipedia.org/wiki/Monomial_order
-- TODO: eval, elt, subst, compose, evaluate, constructOrdered
NMMultivariatePolynomial(R : NMRing, VarSet : List Symbol) ==
          InnerNMMultivariatePolynomial(R, VarSet, coerce("lex")@JLSymbol)

)abbrev domain NMLP NMMultivariateLaurentPolynomial
++ Multivariate laurent polynomial domain using Julia AbstractAlgebra package 
++ Author: G. Vanuxem
++ Basic Functions: degree, eval, coefficient, monomial, differentiate,
++ resultant, gcd
++ Date Created: March, 2024
++ Related Constructors: Polynomial, NMUnivariatePolynomial
++ Also See:
++ AMS Classifications:
++ Keywords: polynomial, multivariate
++ References:
++ Description:
++   This type is a basic representation of sparse, distributed multivariate
++ Laurent polynomials using the Julia package Nemo. It is parameterized by the
++ coefficient ring. The coefficient ring may be non-commutative,
++ but the variables are assumed to commute. The monomial ordering
++ used for internal storage can be one of :lex, :deglex or :degrevlex.
++  For example:
++   VarSet: List Symbol:=[x,y,z]
++   V := OrderedVariableList(VarSet)
++   -- eventually, for later use
++   -- See SparseMultivariatePolynomial
++   -- E := IndexedExponents V
++   LPRing := NMLP(NINT,VarSet)
++   x := x::V::LPRing
++   y := y::V::LPRing
++   z := z::V::LPRing
++   p:=x*2+3*y^2+17*z^-13
++   p^7
-- TODO: eval, elt, subst, compose, evaluate
NMMultivariateLaurentPolynomial(R : NMRing,
    VarSet : List Symbol) : Exports == Implementation where
  NINT      ==> NMInteger
  NRAT      ==> NMFraction(NMInteger)
  NRF        ==> NMRealField
  NCF        ==> NMComplexField
  JI64      ==> JLInt64
  INT       ==> Integer
  PI        ==> PositiveInteger
  NNI       ==> NonNegativeInteger
  parsei    ==> PARSE_-INTEGER$Lisp
  Exports ==> Join(NMCommutativeRing, PolynomialCategory(R, 
                  IndexedExponents(OrderedVariableList(VarSet)),
                    OrderedVariableList(VarSet))) with
    --constant? : % -> Boolean
    --++ constant?(p) checks whether or not p is a constant polynomial.
    --monomial? : % -> Boolean
    --++ monomial?(p) checks whether or not p is a monomial.
    monomialRecursive? : % -> Boolean
    ++ monomialRecursive?(p) checks whether or not p is
    ++ monomial recurisvely (all scalar types).
    --term? : % -> Boolean
    --++ term?(p) checks whether or not p is a one term polynomial.
    termRecursive? : % -> Boolean
    ++ termRecursive?(p) checks whether or not p as one term polynomial
    ++ recursively on all scalar types.
    --univariate? : % -> Boolean
    --++ univariate?(p) checks whether or not p is a univariate polynomial.
    --square? : % -> Boolean
    --++ square?(p) checks whether or not p is a perfect square.
    if R has Algebra(NMFraction(NMInteger)) then
      "+" : (%, Fraction(Integer)) -> %
      ++ p + q is the sum of a p with a rational
      ++ number q (Fraction(Integer))
      "*" : (%, Fraction(Integer)) -> %
      ++ p * q is the product of p with a rational
      ++ number q (Fraction(Integer)) 
      "+" : (Fraction(Integer), %) -> %
      ++ q + p is the sum of a p with a rational
      ++ number q (Fraction(Integer))
      "*" : (Fraction(Integer), %) -> %
      ++ q * p is the product of p with a rational
      ++ q (Fraction(Intger)) 
    "*"      : (%, PositiveInteger) -> %
    ++ * is the positive integer multiplication.
    "*"      : (%, NonNegativeInteger) -> %
    ++ * is the non negative integer multiplication.
    "^" : (%, Integer) -> %
    ++ ^ is the integer exponentiation (possibly negative).
    exactDivide : (%, %) -> %
    ++ exactDivide(p,q) divides p by q if the division is exact.
    jmp2nmp : MultivariatePolynomial(VarSet,R) -> %
    ++ jmp2nmp(p) converts the multivariate polynomial p to
    ++ a Nemo multivariate polynomial.
    factor   : % -> NMFactored(%)
    ++ factor(p) returns the factorization of p.
    degree   : (%, PI) -> NNI
    ++ degree(p,i) returns the degree of the i-th variable.
    length   : % -> NNI
    ++ length(p) retruns the number of terms of p.
    monomials : % -> JLVector(%)
    ++ monomials(p) returns the list of non-zero monomials of p
    ++ includind its coefficients.
    primitiveMonomials : % -> JLVector(%)
    ++ primitiveMonomials(p) returns the list of non-zero
    ++ primitive monomials of p, i.e. not including its coefficients.
    --trailingCoefficient : % -> R
    --++ trailingCoefficient(p) returns the trailing coefficientof p.
    constantCoefficient : % -> R
    ++ constantCoefficient(p) returns the constant of p.
    symbols : () -> JLVector(JLObject)
    ++ symbols() returns a Julia vector of variables (Julia symbols).
    numberOfVariables : ()  -> JLObject
    ++ numberOfVariables() returns the number of variables.
    gens  : () -> JLVector(%)
    ++ gens() returns a vector of the generators (variables).
    gen : Integer -> %
    ++ gen(i) returns the i-th generator.
    gen?  : % -> Boolean
    ++ gen?(lp) checks whether or not lp is a generator.
    variableIndex : % -> JLObjInt64
    ++ variableIndex(var) returns the index of the variable var.
    ++ Julia raises an error if var is not  
    coefficients : % -> JLVector(R)
    ++ coefficients(p) returns a Julia vector of coefficients of p.
    vectorOfTerms : % -> JLVector(%)
    ++ terms(lp) returns the vector of terms.
    exponent_vectors : % -> JLVector(JLVector(JLObjInt64))
    ++ exponent_vectors(lp) returns the exponent vectors.
    leading_monomial : % -> %
    ++ leading_monomial(lp) returns the leading monomial.
    leading_term : % -> %
    ++ leading_term(lp) returns the leading term.
    leading_exponent_vector : % -> JLVector(JLObjInt64)
    ++ leading_exponent_vector(lp) returns the of leading exponent.

    coerce : % ->
      NMMultivariateLaurentPolynomial(NMInteger, VarSet)
    ++ coerce(lp) coerces lp.
    coerce : % ->
      NMMultivariateLaurentPolynomial(NMFraction(NMInteger), VarSet)
    ++ coerce(lp) coerces lp.
    coerce : % ->
      NMMultivariateLaurentPolynomial(NMRealField, VarSet)
    ++ coerce(lp) coerces lp.
    coerce : % ->
      NMMultivariateLaurentPolynomial(NMComplexField, VarSet)
    ++ coerce(lp) coerces lp.

    mapCoefficients : (JLObject, %) -> %
    ++ mapCoefficients(jmap, p) applies the Julia map jmap to the
    ++ coefficients of p an returns the modified Laurent polynomial.
    ++ Use coerce to change the base ring instead of mapCoefficients.

    --evaluate : (%, JLVector(JLObject)) -> JLObject
    --++ evaluate(lp,vec)

    --derivative : (%, OrderedVariableList(VarSet)) -> %
    --derivative : (%, NonNegativeInteger) -> %
    nemoMLPPrint : Boolean -> Boolean
    ++ nemoMLPPrint(bool) set the output mode. If set to false, use
    ++ the FriCAS output mode if possible. Otherwise use the Nemo one (default).
  Implementation ==> add
    import from JLUtilityFunctions
    import from JLStringUtilities

    jlInitialize(true)
    Rep := SExpression
    nprint := true

    tmp : SExpression := devaluate(R)$Lisp
    op_of_Ring : Symbol := CAR(tmp)$Lisp

    -- FriCAS NMRing of R
    NRing : String := string(op_of_Ring)
    NMLPRing := jlRegexReplace(
      concat("MP", FORMAT(false, "~a", tmp)$Lisp),
        jlRegex("[(|)|\s]"), jlSubstitute(""))

    -- Check VarSet (TODO: reflect SMP)
    #VarSet ~= #removeDuplicates(VarSet) =>
      error "Duplicate symbols in NMMultivariateLaurentPolynomial constructor" 
     
    -- List of double-quoted vars     
    lvars := map(v +-> string(v), VarSet)$ListFunctions2(Symbol, String)
    -- vars for polynomial_ring() arguments
    jvars := first lines formatExpression(lvars::OutputForm)$Format1D
    
    -- Our Julia ring
    NMLPRing := concat([NMLPRing, concat(lvars)])

    getind(a) ==> concat(["getindex(refs,", string(jlId(a)), ")"])
    junfunc(func, a) ==> make_jlref_wcall1(func, a)$Lisp
    jbinfunc(func,a,b) ==> make_jlref_wcall2(func, a, b)$Lisp
    junbfunc(bfunc, a) ==> jl_call1_bool_wrapped_index(bfunc, jlId(a))$Lisp
    jbinbfunc(op,a,b) ==>
      jl_call2_bool_wrapped_index(op, jlId(a), jlId(b))$Lisp

    -- Set up the ring
    tuple : Boolean := jbinbfunc("isa", jobject(jlNMRing()$R)$JLObject,
      jobject("Tuple")$JLObject)
    if tuple then
      jlEvalString(concat([NMLPRing, "=laurent_polynomial_ring(",
        jlNMRing()$R, "[1],", jvars,")"])$String)
    else
      jlEvalString(concat([NMLPRing, "=laurent_polynomial_ring(",
        jlNMRing()$R, ",", jvars,")"])$String)

    strToExpr(s : String) : Union(Expression(Fraction Integer), "failed") ==
      jlRegexMatch?(s, jlRegex("[\[|{|O]")) => "failed"
      str := concat("0$Expression(Fraction Integer)+", s)
      af := parse(str)$InputForm
      av := interpret_in_new_env(af)$InputForm
      retractIfCan(av)$AnyFunctions1(Expression(Fraction Integer))

    if R is NMFraction(NMInteger) then
      p : % + q : Fraction(Integer) == jbinfunc("+", p, coerce(q)@NRAT)
      p : % * q : Fraction(Integer) == jbinfunc("*", p, coerce(q)@NRAT)
      q : Fraction(Integer) + p : % == jbinfunc("+", coerce(q)@NRAT, p)
      q : Fraction(Integer) * p : % == jbinfunc("*", coerce(q)@NRAT, p)
      (p / q) : % == jbinfunc("/", p, q)

    jlNMRing() == NMLPRing
    jlObject() == jlEvalString(concat(["string(", NMLPRing,")"]))@String
    nemoMLPPrint(b) ==
      oldnprint := nprint
      nprint:=b
      oldnprint

    0 == jlref(concat(["zero(",NMLPRing,"[1])"]))
    1 == jlref(concat(["one(",NMLPRing,"[1])"]))
    --monomial?(p) == junbfunc("is_monomial",p)
    monomialRecursive?(p) == junbfunc("is_monomial_recursive",p)
    --term?(p) == junbfunc("is_term",p)
    termRecursive?(p) == junbfunc("is_term_recursive",p)
    unit?(p) == junbfunc("is_unit",p)
    --univariate?(p) == junbfunc("is_univariate",p)
    --square?(p) == junbfunc("is_square",p)

    a : R * b : % == jbinfunc("*",a,b)
    a : % * b : R == jbinfunc("*",a,b)
    i : INT  * b : % == jbinfunc("*", coerce(i)@NINT, b)
    a : % * i : INT  == jbinfunc("*", a, coerce(i)@NINT)
    a : % * i : PI  == jbinfunc("*", a, coerce(i pretend Integer)@NINT)
    a : % * i : NNI  == jbinfunc("*", a, coerce(i pretend Integer)@NINT)
    a : % ^ i : PI  == jbinfunc("^", a, coerce(i pretend Integer)@NINT)
    a : % ^ i : NNI  == jbinfunc("^", a, coerce(i pretend Integer)@NINT)
    a : % ^ i : INT  == jbinfunc("^", a, coerce(i pretend Integer)@NINT)
    exactDivide(p,q) == jbinfunc("divexact", p, q)

    monomial(c : R, k : IndexedExponents(OrderedVariableList(VarSet))) : % ==
      res : % := c::%
      while k ~= 0 repeat
        v := leadingSupport(k)
        e := leadingCoefficient(k)
        res := res * (v::%)^e
        k := reductum(k)
      res

    constructOrdered(terms : List Record(k: IndexedExponents(OrderedVariableList(VarSet)), c: R)) : % ==
      res : % := 0
      for t in terms repeat
        res := res + monomial(t.c, t.k)
      res

    construct(terms) == constructOrdered(terms)

    -- Nemo interface (AbstractAlgebra)
    symbols() == jlref(concat(["symbols(", NMLPRing,"[1])"]))
    numberOfVariables() == jlref(concat(["number_of_variables(", NMLPRing,"[1])"]))
    gens() == jlref(concat(["gens(",NMLPRing,"[1])"]))
    gen(i) == jlref(concat(["gen(",NMLPRing, "[1],", string(i) ,")"]))
    gen?(x) == junbfunc("is_gen", x)
    variableIndex(var) == junfunc("var_index", var)

    coefficients(p) : JLVector(R) ==
      jlref(concat ["collect(coefficients(", getind(p),"))"])
    coefficients(p) : List(R) ==
      members(jlref(concat ["collect(coefficients(",
        getind(p),"))"])$JLVector(R))
    vectorOfTerms(p) ==
      jlref(concat ["collect(terms(", getind(p),"))"])
    exponent_vectors(p) == junfunc("exponent_vectors", p)
    leading_monomial(p) == junfunc("leading_monomial", p)
    leading_term(p) == junfunc("leading_term", p)
    leading_exponent_vector(p) == junfunc("leading_exponent_vector", p)

    coerce(p) : NMMultivariateLaurentPolynomial(NMInteger,VarSet) ==
      jlref(concat ["change_base_ring(ZZ,", getind(p), ")"])
    coerce(p) : NMMultivariateLaurentPolynomial(NMFraction(NMInteger),VarSet) ==
      jlref(concat ["change_base_ring(QQ,", getind(p), ")"])
    coerce(p) : NMMultivariateLaurentPolynomial(NMRealField,VarSet) ==
      jlref(concat ["change_base_ring(NRF,", getind(p), ")"])
    coerce(p) : NMMultivariateLaurentPolynomial(NMComplexField,VarSet) ==
      jlref(concat ["change_base_ring(NCF,", getind(p), ")"])
    mapCoefficients(func, p) ==
      jlref(concat ["(", getind(func),",", getind(p),")"])

    --evaluate(p, ::Vector)

    --derivative(p, x)
    --derivative(p, i::Int)

    (p1:% exquo p2:%) ==
      ret : JLObjTuple := jbinfunc("divides", p1, p2)
      not jlEvalString(concat(["first(", getind(ret), ")"]))@Boolean
        => "failed"
      junfunc("last", ret)@%

    -- reductum(p) == junfunc("tail",p)
    gcd(p1,p2)  == jbinfunc("gcd",p1,p2)
    lcm(p1,p2)  == jbinfunc("lcm",p1,p2)
    factor(a : %) : NMFactored(%) == factor(a)$NMFactored(%)
    factor(a : %) : Factored(%) == factor(a)$NMFactored(%)
    --mainVariable(p : %) ==
    --  jlEvalString(concat(["is_constant(", getind(p),")"]))@Boolean
    --    => "failed"
    --  sym : String := jlEvalString(concat ["string(vars(",getind(p),")[1])"])  
    --  variable(sym::Symbol)$OrderedVariableList(VarSet)
    variables(p) == enumerate()$OrderedVariableList(VarSet)
    length(p) == jlEvalString(concat(["length(", getind(p),")"]))
    leadingMonomial(p) == junfunc("leading_term", p)
    leadingCoefficient(p : %) ==
      junfunc("leading_coefficient", p)
    --trailingCoefficient(p) ==
    --  jlref(concat ["trailing_coefficient(", getind(p),")"])$R
    constantCoefficient(p) ==
      jlref(concat ["constant_coefficient(", getind(p),")"])$R
    monomials(p) : List(%) ==
      vmon := jlref(concat ["collect(terms(", getind(p),"))"])$JLVector(%)
      l : List(%) := [] 
      for i in 1..#vmon repeat
        l := concat(l, vmon.i)
      l
    monomials(p) : JLVector(%) ==
      jlref(concat ["collect(terms(", getind(p),"))"])$JLVector(%)
    primitiveMonomials(p) : List(%) ==
      terms  := jlref(concat ["collect(monomials(", getind(p),"))"])$JLVector(%)
      l : List(%) := [] 
      for i in 1..#terms repeat
        l := concat(l, terms.i)
      l
    primitiveMonomials(p) : JLVector(%) ==
      jlref(concat ["collect(monomials(", getind(p),"))"])$JLVector(%)
    leadingTerm(p) ==
      error "Unsupported operation"
      tp: % := junfunc("leading_term", p)
      ind := getind(tp)
      coef := leadingCoefficient p
      -- TODO ???
      vs := jlref(concat(["vars(", ind, ")"]))$JLVector(%)
      res : List(Record(k:OrderedVariableList(VarSet),c:NNI)):=[]
      for i in 1..#vs repeat
        elt := getind(qelt(vs,i))
        sym : String := jlEvalString(concat ["string(", elt,")"])
        exp := jlEvalString(concat(["degree(", ind,",", elt, ")"]))@NNI
        res:=concat(res,
          [coerce(variable(coerce(sym)$Symbol)$OrderedVariableList(VarSet))@OrderedVariableList(VarSet),
            exp]$Record(k:OrderedVariableList(VarSet),c:NNI))
      [construct(res)$IndexedExponents(OrderedVariableList(VarSet)), coef]
    --listOfTerms(p) == 
    --  v : JLVector(%) := jlref(concat ["collect(terms(", getind(p),"))"])
    --  ret : List(Record(k: IndexedExponents(OrderedVariableList(VarSet)),c: R)) := []
    --  for i in 1..#v repeat
    --    ind := getind(v.i)
    --    coef := jlref(concat ["coeff(", ind,",1)"])$R
    --    vs := jlref(concat(["vars(", ind, ")"]))$JLVector(%)
    --    res : List(Record(k:OrderedVariableList(VarSet),c:NNI)):=[]
    --    for j in 1..#vs repeat
    --      sym : String := jlEvalString(concat ["string(", getind(qelt(vs,j)),")"])
    --      exp := jlEvalString(concat(["degree(", ind,",", sym, ")"]))@NNI
    --      res:= concat(res,
    --        [coerce(variable(coerce(sym)$Symbol)$OrderedVariableList(VarSet))@OrderedVariableList(VarSet),
    --          exp]$Record(k:OrderedVariableList(VarSet),c:NNI))
    --    ret := concat(ret,[construct(res)$IndexedExponents(OrderedVariableList(VarSet)), coef])
    --  ret
    --minimumDegree(p) ==
    --  lterm := jlref(concat ["last(collect(terms(", getind(p),")))"])
    --  ind := getind(lterm)
    --  sym := jlEvalString(concat(["string(last(vars(", ind, ")))"]))@String
    --  exp := jlEvalString(concat(["degree(", ind,",", sym, ")"]))@NNI
    --  monomial(exp,
    --    coerce(variable(coerce(sym)$Symbol)$OrderedVariableList(VarSet)))
    --      $IndexedExponents(OrderedVariableList(VarSet))
    --degree(p : %) ==
    --  ind := getind(p)
    --  tp : JLObject := jlref(concat(["leading_monomial(", ind, ")"]))
    --  ind := getind(tp)
    --  vs := jlref(concat(["vars(", ind, ")"]))$JLVector(%)
    --  res : List(Record(k:OrderedVariableList(VarSet),c:NNI)):=[]
    --  for i in 1..#vs repeat
    --    sym : String := jlEvalString(concat ["string(", getind(qelt(vs,i)),")"])
    --    exp := jlEvalString(concat(["degree(", ind,",", sym, ")"]))@NNI
    --    res:=concat(res,
    --      [coerce(variable(coerce(sym)$Symbol)$OrderedVariableList(VarSet))@OrderedVariableList(VarSet),
    --        exp]$Record(k:OrderedVariableList(VarSet),c:NNI))
    --  construct(res)$IndexedExponents(OrderedVariableList(VarSet))
    --degree(p : %, var : OrderedVariableList(VarSet)) ==
    --  ind := lookup(var)
    --  jlEvalString(concat(["degree(", getind(p),",", string(ind),")"]))@NNI
    --degree(p : %, index : PI) ==
    --  jlEvalString(concat(["degree(", getind(p),",", string(index),")"]))@NNI

    -- unitCanonical(p) == junfunc("canonical_unit", p) -- The Nemo one 

    if R has DivisionRing then
      recip(p) ==
        ret : JLObjTuple := jbinfunc("divides", 1$R, p)
        not jlEvalString(concat(["first(", getind(ret), ")"]))@Boolean
          => "failed"
        junfunc("last",ret) pretend %
      p/(r : R) == inv(r)*p
      unitNormal(p) ==
        unitC : R := junfunc("canonical_unit", p)
        a := inv unitC
        [unitC::%, p * a , a::%]
      unitCanonical(p) ==
        a : R := junfunc("canonical_unit", p)
        p * inv a
    else
      recip(p) ==
        unit?(p) => p
        "failed"

    jmp2nmp(mp) : % ==
      p: String := first(lines formatExpression(mp::OutputForm)$Format1D)
      ret := jlRegexReplace(p, jlRegex("/"), jlSubstitute("//"))
      jlref(ret)

    --retractIfCan(p : %) : Union(R,"failed") ==
    --  jlEvalString(concat(["is_constant(", getind(p),")"]))@Boolean
    --    => jlref(string(p))$R
    --  "failed"

    coerce(v : OrderedVariableList(VarSet)) ==
      i := lookup(v)$OrderedVariableList(VarSet)
      jlref(concat([NMLPRing,"[2][", string(i),"]"]))
    coerce(i : Integer) == jlref(concat([NMLPRing, "[1](", string(i), ")"]))
    coerce(c : R) == jlref(concat([NMLPRing, "[1](", getind(c),")"]))
    coerce(p : %) : OutputForm ==
      str := jlRegexReplace(string(p), jlString("//"),jlString("/"))
      if nprint then str pretend OutputForm
      else
        (ret := strToExpr(str)) case "failed" => str pretend OutputForm
        coerce(ret)

